{"version":3,"sources":["../src/types/constants.ts","../src/rest/info/general.ts","../src/rest/info/spot.ts","../src/rest/info/perpetuals.ts","../src/utils/helpers.ts","../src/utils/errors.ts","../src/rest/info.ts","../src/rest/exchange.ts","../src/utils/signing.ts","../src/utils/environment.ts","../src/websocket/connection.ts","../src/websocket/subscriptions.ts","../src/utils/rateLimiter.ts","../src/rest/custom.ts","../src/index.ts","../src/utils/symbolConversion.ts"],"sourcesContent":["export const BASE_URLS = {\n    PRODUCTION: 'https://api.hyperliquid.xyz',\n    TESTNET: 'https://api.hyperliquid-testnet.xyz'\n};\n\nexport const WSS_URLS = {\n    PRODUCTION: 'wss://api.hyperliquid.xyz/ws',\n    TESTNET: 'wss://api.hyperliquid-testnet.xyz/ws'\n};\n\nexport const ENDPOINTS = {\n    INFO: '/info',\n    EXCHANGE: '/exchange'\n};\n\nexport enum InfoType {\n    ALL_MIDS = 'allMids',\n    META = 'meta',\n    OPEN_ORDERS = 'openOrders',\n    FRONTEND_OPEN_ORDERS = 'frontendOpenOrders',\n    USER_FILLS = 'userFills',\n    USER_FILLS_BY_TIME = 'userFillsByTime',\n    USER_RATE_LIMIT = 'userRateLimit',\n    ORDER_STATUS = 'orderStatus',\n    L2_BOOK = 'l2Book',\n    CANDLE_SNAPSHOT = 'candleSnapshot',\n    PERPS_META_AND_ASSET_CTXS = 'metaAndAssetCtxs',\n    PERPS_CLEARINGHOUSE_STATE = 'clearinghouseState',\n    USER_FUNDING = 'userFunding',\n    USER_NON_FUNDING_LEDGER_UPDATES = 'userNonFundingLedgerUpdates',\n    FUNDING_HISTORY = 'fundingHistory',\n    SPOT_META = 'spotMeta',\n    SPOT_CLEARINGHOUSE_STATE = 'spotClearinghouseState',\n    SPOT_META_AND_ASSET_CTXS = 'spotMetaAndAssetCtxs',\n    PREDICTED_FUNDINGS = 'predictedFundings',\n    SPOT_DEPLOY_STATE = 'spotDeployState',\n    TOKEN_DETAILS = 'tokenDetails',\n    MAX_BUILDER_FEE = 'maxBuilderFee',\n    HISTORICAL_ORDERS = 'historicalOrders',\n    USER_TWAP_SLICE_FILLS = 'userTwapSliceFills',\n    SUB_ACCOUNTS = 'subAccounts',\n    VAULT_DETAILS = 'vaultDetails',\n    USER_VAULT_EQUITIES = 'userVaultEquities',\n    USER_ROLE = 'userRole',\n    DELEGATIONS = 'delegations',\n    DELEGATOR_SUMMARY = 'delegatorSummary',\n    PERPS_AT_OPEN_INTEREST_CAP = 'perpsAtOpenInterestCap',\n    DELEGATOR_HISTORY = 'delegatorHistory',\n    DELEGATOR_REWARDS = 'delegatorRewards',\n    VALIDATOR_SUMMARIES = 'validatorSummaries',\n    VAULT_SUMMARIES = 'vaultSummaries',\n    BLOCK_DETAILS = 'blockDetails',\n    TX_DETAILS = 'txDetails',\n    USER_DETAILS = 'userDetails',\n    USER_FEES = 'userFees',\n    PORTFOLIO = 'portfolio',\n    PRE_TRANSFER_CHECK = 'preTransferCheck',\n    REFERRAL = 'referral',\n    EXTRA_AGENTS = 'extraAgents',\n    IS_VIP = 'isVip',\n    LEGAL_CHECK = 'legalCheck',\n    USER_TWAP_SLICE_FILLS_BY_TIME = 'userTwapSliceFillsByTime',\n    TWAP_HISTORY = 'twapHistory',\n    USER_TO_MULTI_SIG_SIGNERS = 'userToMultiSigSigners'\n}\n\nexport enum ExchangeType {\n    ORDER = 'order',\n    CANCEL = 'cancel',\n    CANCEL_BY_CLOID = 'cancelByCloid',\n    SCHEDULE_CANCEL = 'scheduleCancel',\n    MODIFY = 'modify',\n    BATCH_MODIFY = 'batchModify',\n    UPDATE_LEVERAGE = 'updateLeverage',\n    UPDATE_ISOLATED_MARGIN = 'updateIsolatedMargin',\n    USD_SEND = 'usdSend',\n    SPOT_SEND = 'spotSend',\n    WITHDRAW = 'withdraw3',\n    SPOT_USER = 'spotUser',\n    VAULT_TRANSFER = 'vaultTransfer',\n    SET_REFERRER = 'setReferrer',\n    USD_CLASS_TRANSFER = 'usdClassTransfer',\n    TWAP_ORDER = 'twapOrder',\n    TWAP_CANCEL = 'twapCancel',\n    APPROVE_AGENT = 'approveAgent',\n    APPROVE_BUILDER_FEE = 'approveBuilderFee',\n    EVM_USER_MODIFY = 'evmUserModify'\n}\n\nexport const WEBSOCKET = {\n    MAINNET_URL: 'wss://api.hyperliquid.xyz/ws',\n    TESTNET_URL: 'wss://api.hyperliquid-testnet.xyz/ws'\n};\n\nexport const SDK_CODE = 'PLACEHOLDER';","// src/rest/info/general.ts\n\nimport { \n    AllMids, \n    Meta, \n    UserOpenOrders, \n    FrontendOpenOrders, \n    UserFills, \n    UserRateLimit, \n    OrderStatus, \n    L2Book, \n    CandleSnapshot,\n    HistoricalOrder,\n    TwapSliceFill,\n    SubAccount,\n    VaultDetails,\n    VaultEquity,\n    UserRole,\n    Delegation,\n    DelegatorSummary,\n    DelegatorHistoryEntry,\n    DelegatorReward,\n    ValidatorSummary,\n    VaultSummary,\n    UserFees,\n    PortfolioPeriods,\n    PreTransferCheck,\n    Referral,\n    ExtraAgent,\n    LegalCheck,\n    TwapHistory,\n    MultiSigSigners\n} from '../../types';\nimport { HttpApi } from '../../utils/helpers';\nimport { SymbolConversion } from '../../utils/symbolConversion';\nimport { InfoType } from '../../types/constants';\nimport { Hyperliquid } from '../../index';\n\nexport class GeneralInfoAPI {\n    private parent: Hyperliquid;\n\n    constructor(\n        private httpApi: HttpApi, \n        private symbolConversion: SymbolConversion,\n        parent: Hyperliquid\n    ) {\n        this.parent = parent;\n    }\n\n    async getAllMids(rawResponse: boolean = false): Promise<AllMids> {\n        const response = await this.httpApi.makeRequest<AllMids>({ type: InfoType.ALL_MIDS });\n\n        if (rawResponse) {\n            return response;\n        } else {\n            const convertedResponse: any = {};\n            for (const [key, value] of Object.entries(response)) {\n                const convertedKey = await this.symbolConversion.convertSymbol(key);\n                const convertedValue = parseFloat(value as string);\n                convertedResponse[convertedKey] = convertedValue;\n            }\n            return convertedResponse;\n        }\n    }\n\n    async getUserOpenOrders(user: string, rawResponse: boolean = false): Promise<UserOpenOrders> {\n        await this.parent.ensureInitialized();\n        const response = await this.httpApi.makeRequest({ type: InfoType.OPEN_ORDERS, user: user });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getFrontendOpenOrders(user: string, rawResponse: boolean = false): Promise<FrontendOpenOrders> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.FRONTEND_OPEN_ORDERS, user: user }, 20);\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getUserFills(user: string, rawResponse: boolean = false): Promise<UserFills> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.USER_FILLS, user: user }, 20);\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getUserFillsByTime(user: string, startTime: number, endTime?: number, rawResponse: boolean = false): Promise<UserFills> {\n        let params: { user: string; startTime: number; type: string; endTime?: number } = {\n            user: user,\n            startTime: Math.round(startTime),\n            type: InfoType.USER_FILLS_BY_TIME\n        };\n        \n        if (endTime) {\n            params.endTime = Math.round(endTime)\n        }\n\n        const response = await this.httpApi.makeRequest(params, 20);\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getUserRateLimit(user: string, rawResponse: boolean = false): Promise<UserRateLimit> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.USER_RATE_LIMIT, user: user }, 20);\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getOrderStatus(user: string, oid: number | string, rawResponse: boolean = false): Promise<OrderStatus> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.ORDER_STATUS, user: user, oid: oid });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getL2Book(coin: string, rawResponse: boolean = false): Promise<L2Book> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.L2_BOOK, coin: await this.symbolConversion.convertSymbol(coin, \"reverse\") });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getCandleSnapshot(coin: string, interval: string, startTime: number, endTime: number, rawResponse: boolean = false): Promise<CandleSnapshot> {\n        const response = await this.httpApi.makeRequest({ \n            type: InfoType.CANDLE_SNAPSHOT, \n            req: { coin: await this.symbolConversion.convertSymbol(coin, \"reverse\"), interval: interval, startTime: startTime, endTime: endTime } \n        });\n\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response, [\"s\"]);\n    }\n\n    // Add these methods to src/rest/info/general.ts\n\n    async getMaxBuilderFee(user: string, builder: string, rawResponse: boolean = false): Promise<number> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.MAX_BUILDER_FEE,\n            user,\n            builder\n        });\n        return rawResponse ? response : this.symbolConversion.convertToNumber(response);\n    }\n\n    async getHistoricalOrders(user: string, rawResponse: boolean = false): Promise<HistoricalOrder[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.HISTORICAL_ORDERS,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getUserTwapSliceFills(user: string, rawResponse: boolean = false): Promise<TwapSliceFill[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.USER_TWAP_SLICE_FILLS,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getSubAccounts(user: string, rawResponse: boolean = false): Promise<SubAccount[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.SUB_ACCOUNTS,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getVaultDetails(vaultAddress: string, user?: string, rawResponse: boolean = false): Promise<VaultDetails> {\n        const params: any = {\n            type: InfoType.VAULT_DETAILS,\n            vaultAddress\n        };\n        \n        if (user) {\n            params.user = user;\n        }\n        \n        const response = await this.httpApi.makeRequest(params);\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getUserVaultEquities(user: string, rawResponse: boolean = false): Promise<VaultEquity[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.USER_VAULT_EQUITIES,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getUserRole(user: string, rawResponse: boolean = false): Promise<UserRole> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.USER_ROLE,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getDelegations(user: string, rawResponse: boolean = false): Promise<Delegation[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.DELEGATIONS,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getDelegatorSummary(user: string, rawResponse: boolean = false): Promise<DelegatorSummary> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.DELEGATOR_SUMMARY,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getDelegatorHistory(user: string, rawResponse: boolean = false): Promise<DelegatorHistoryEntry[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.DELEGATOR_HISTORY,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getDelegatorRewards(user: string, rawResponse: boolean = false): Promise<DelegatorReward[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.DELEGATOR_REWARDS,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async validatorSummaries(rawResponse: boolean = false): Promise<ValidatorSummary[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.VALIDATOR_SUMMARIES\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async vaultSummaries(rawResponse: boolean = false): Promise<VaultSummary[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.VAULT_SUMMARIES\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async userFees(user: string, rawResponse: boolean = false): Promise<UserFees> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.USER_FEES,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async portfolio(user: string, rawResponse: boolean = false): Promise<PortfolioPeriods> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.PORTFOLIO,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async preTransferCheck(user: string, source: string, rawResponse: boolean = false): Promise<PreTransferCheck> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.PRE_TRANSFER_CHECK,\n            user,\n            source\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async referral(user: string, rawResponse: boolean = false): Promise<Referral> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.REFERRAL,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async extraAgents(user: string, rawResponse: boolean = false): Promise<ExtraAgent[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.EXTRA_AGENTS,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async isVip(user: string, rawResponse: boolean = false): Promise<boolean> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.IS_VIP,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async legalCheck(user: string, rawResponse: boolean = false): Promise<LegalCheck> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.LEGAL_CHECK,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async userTwapSliceFillsByTime(\n        user: string, \n        startTime: number, \n        endTime?: number, \n        aggregateByTime?: boolean, \n        rawResponse: boolean = false\n    ): Promise<TwapSliceFill[]> {\n        const params: any = {\n            type: InfoType.USER_TWAP_SLICE_FILLS_BY_TIME,\n            user,\n            startTime\n        };\n        \n        if (endTime !== undefined) params.endTime = endTime;\n        if (aggregateByTime !== undefined) params.aggregateByTime = aggregateByTime;\n        \n        const response = await this.httpApi.makeRequest(params);\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async twapHistory(user: string, rawResponse: boolean = false): Promise<TwapHistory[]> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.TWAP_HISTORY,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async userToMultiSigSigners(user: string, rawResponse: boolean = false): Promise<MultiSigSigners | null> {\n        const response = await this.httpApi.makeRequest({\n            type: InfoType.USER_TO_MULTI_SIG_SIGNERS,\n            user\n        });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n}\n","import { SpotMeta, SpotClearinghouseState, SpotMetaAndAssetCtxs } from '../../types';\nimport { HttpApi } from '../../utils/helpers';\nimport { InfoType } from '../../types/constants';\nimport { SymbolConversion } from '../../utils/symbolConversion';\n\nexport class SpotInfoAPI {\n    private httpApi: HttpApi;\n    private symbolConversion: SymbolConversion;\n\n    constructor(httpApi: HttpApi, symbolConversion: SymbolConversion) {\n        this.httpApi = httpApi;\n        this.symbolConversion = symbolConversion;\n    }\n\n    async getSpotMeta(rawResponse: boolean = false): Promise<SpotMeta> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.SPOT_META });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response, [\"name\", \"coin\", \"symbol\"], \"SPOT\");\n    }\n\n    async getSpotClearinghouseState(user: string, rawResponse: boolean = false): Promise<SpotClearinghouseState> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.SPOT_CLEARINGHOUSE_STATE, user: user });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response, [\"name\", \"coin\", \"symbol\"], \"SPOT\");\n    }\n\n    async getSpotMetaAndAssetCtxs(rawResponse: boolean = false): Promise<SpotMetaAndAssetCtxs> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.SPOT_META_AND_ASSET_CTXS });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getTokenDetails(tokenId: string, rawResponse: boolean = false): Promise<any> {\n        const response = await this.httpApi.makeRequest({ \n            type: InfoType.TOKEN_DETAILS,\n            tokenId: tokenId\n        }, 20);\n        \n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n    \n    async getSpotDeployState(user: string, rawResponse: boolean = false): Promise<any> {\n        const response = await this.httpApi.makeRequest({ \n            type: InfoType.SPOT_DEPLOY_STATE,\n            user: user\n        }, 20);\n        \n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n}\n","import { Meta, MetaAndAssetCtxs, ClearinghouseState, UserFunding, UserNonFundingLedgerUpdates, FundingHistory, PredictedFundings, PerpsAtOpenInterestCap } from '../../types';\nimport { HttpApi } from '../../utils/helpers';\nimport { InfoType } from '../../types/constants';\nimport { SymbolConversion } from '../../utils/symbolConversion';\nimport { Hyperliquid } from '../../index';\n\nexport class PerpetualsInfoAPI {\n    private httpApi: HttpApi;\n    private symbolConversion: SymbolConversion;\n    private parent: Hyperliquid;\n\n    constructor(httpApi: HttpApi, symbolConversion: SymbolConversion, parent: Hyperliquid) {\n        this.httpApi = httpApi;\n        this.symbolConversion = symbolConversion;\n        this.parent = parent;\n    }\n\n    async getMeta(rawResponse: boolean = false): Promise<Meta> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.META });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response, [\"name\", \"coin\", \"symbol\"], \"PERP\");\n    }\n\n    async getMetaAndAssetCtxs(rawResponse: boolean = false): Promise<MetaAndAssetCtxs> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.PERPS_META_AND_ASSET_CTXS });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response, [\"name\", \"coin\", \"symbol\"], \"PERP\");\n    }\n\n    async getClearinghouseState(user: string, rawResponse: boolean = false): Promise<ClearinghouseState> {\n        const response = await this.httpApi.makeRequest({ type: InfoType.PERPS_CLEARINGHOUSE_STATE, user: user });\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getUserFunding(user: string, startTime: number, endTime?: number, rawResponse: boolean = false): Promise<UserFunding> {\n        const response = await this.httpApi.makeRequest({ \n                type: InfoType.USER_FUNDING, \n                user: user,\n                startTime: startTime,\n                endTime: endTime\n            }, 20);\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getUserNonFundingLedgerUpdates(user: string, startTime: number, endTime?: number, rawResponse: boolean = false): Promise<UserNonFundingLedgerUpdates> {\n        const response = await this.httpApi.makeRequest({ \n                type: InfoType.USER_NON_FUNDING_LEDGER_UPDATES, \n                user: user,\n                startTime: startTime,\n                endTime: endTime\n            }, 20);\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getFundingHistory(coin: string, startTime: number, endTime?: number, rawResponse: boolean = false): Promise<FundingHistory> {\n        await this.parent.ensureInitialized();\n        const response = await this.httpApi.makeRequest({ \n                type: InfoType.FUNDING_HISTORY, \n                coin: await this.symbolConversion.convertSymbol(coin, \"reverse\"), \n                startTime: startTime, \n                endTime: endTime \n            }, 20);\n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getPredictedFundings(rawResponse: boolean = false): Promise<PredictedFundings> {\n        const response = await this.httpApi.makeRequest({ \n            type: InfoType.PREDICTED_FUNDINGS \n        }, 20);\n        \n        return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n    }\n\n    async getPerpsAtOpenInterestCap(rawResponse: boolean = false): Promise<PerpsAtOpenInterestCap> {\n        const response = await this.httpApi.makeRequest({ \n            type: InfoType.PERPS_AT_OPEN_INTEREST_CAP \n        }) as string[];\n        \n        if (rawResponse) {\n            return response;\n        }\n    \n        // Convert each symbol in the array\n        const convertedResponse = await Promise.all(\n            response.map((symbol: string) => this.symbolConversion.convertSymbol(symbol, \"\", \"PERP\"))\n        );\n    \n        return convertedResponse;\n    }\n}\n","import axios, { AxiosInstance } from 'axios';\nimport { handleApiError } from './errors';\nimport { RateLimiter } from './rateLimiter';\n\n\nexport class HttpApi {\n    private client: AxiosInstance;\n    private endpoint: string;\n    private rateLimiter: RateLimiter;\n\n    constructor(baseUrl: string, endpoint: string = \"/\", rateLimiter: RateLimiter) {\n        this.endpoint = endpoint;\n        this.client = axios.create({\n            baseURL: baseUrl,\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        });\n        this.rateLimiter = rateLimiter;\n    }\n\n    async makeRequest<T>(payload: any, weight: number = 2, endpoint: string = this.endpoint,): Promise<T> {\n        try {\n\n            await this.rateLimiter.waitForToken(weight);\n\n            const response = await this.client.post(endpoint, payload);\n            return response.data;\n        } catch (error) {\n            handleApiError(error);\n        }\n    }\n}\n","export class HyperliquidAPIError extends Error {\n    constructor(public code: string, message: string) {\n    super(message);\n    this.name = 'HyperliquidAPIError';\n    }\n}\n\nexport class AuthenticationError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'AuthenticationError';\n    }\n}\n\nexport function handleApiError(error: any): never {\n    if (error.response) {\n    //The request was made and the server responded with a status code\n    //that falls out of the range of 2xx\n    throw new HyperliquidAPIError(\n        error.response.data.code || error.response.status || 'UNKNOWN_ERROR',\n        error.response.data.message || error.response.data || 'An unknown error occurred'\n    );\n    } else if (error.request) {\n    //The request was made but no response was received\n    throw new HyperliquidAPIError('NETWORK_ERROR', 'No response received from the server');\n    } else {\n    //Something happened in setting up the request that triggered an Error\n    throw new HyperliquidAPIError('REQUEST_SETUP_ERROR', error.message);\n    }\n}","import { RateLimiter } from '../utils/rateLimiter';\nimport { GeneralInfoAPI } from './info/general';\nimport { SpotInfoAPI } from './info/spot';\nimport { PerpetualsInfoAPI } from './info/perpetuals';\nimport { HttpApi } from '../utils/helpers';\nimport { SymbolConversion } from '../utils/symbolConversion';\nimport { Hyperliquid } from '../index';\n\nimport { \n    AllMids, \n    Meta, \n    UserOpenOrders, \n    FrontendOpenOrders, \n    UserFills, \n    UserRateLimit, \n    OrderStatus, \n    L2Book, \n    CandleSnapshot,\n    VaultEquity,\n    HistoricalOrder,\n    TwapSliceFill,\n    SubAccount,\n    VaultDetails,\n    DelegatorReward,\n    DelegatorHistoryEntry,\n    DelegatorSummary,\n    Delegation,\n    UserRole,\n    ValidatorSummary,\n    VaultSummary,\n    UserFees,\n    PortfolioPeriods,\n    PreTransferCheck,\n    Referral,\n    ExtraAgent,\n    LegalCheck,\n    TwapHistory,\n    MultiSigSigners\n} from '../types/index';\n\nimport { InfoType, ENDPOINTS } from '../types/constants';\n\nexport class InfoAPI {\n    public spot: SpotInfoAPI;\n    public perpetuals: PerpetualsInfoAPI;\n    private httpApi: HttpApi;\n    private generalAPI: GeneralInfoAPI;\n    private symbolConversion: SymbolConversion;\n    private parent: Hyperliquid;\n\n    constructor(\n        baseURL: string, \n        rateLimiter: RateLimiter, \n        symbolConversion: SymbolConversion,\n        parent: Hyperliquid\n    ) {\n        this.httpApi = new HttpApi(baseURL, ENDPOINTS.INFO, rateLimiter);\n        this.symbolConversion = symbolConversion;\n        this.parent = parent;\n        \n        this.generalAPI = new GeneralInfoAPI(this.httpApi, this.symbolConversion, this.parent);\n        this.spot = new SpotInfoAPI(this.httpApi, this.symbolConversion);\n        this.perpetuals = new PerpetualsInfoAPI(this.httpApi, this.symbolConversion, this.parent);\n    }\n\n    async getAssetIndex(assetName: string): Promise<number | undefined> {\n        await this.parent.ensureInitialized();\n        return await this.symbolConversion.getAssetIndex(assetName);\n    }\n\n    async getInternalName(exchangeName: string): Promise<string | undefined> {\n        await this.parent.ensureInitialized();\n        return await this.symbolConversion.convertSymbol(exchangeName);\n    }\n\n    async getAllAssets(): Promise<{ perp: string[], spot: string[] }> {\n        await this.parent.ensureInitialized();\n        return await this.symbolConversion.getAllAssets();\n    }\n\n    async getAllMids(rawResponse: boolean = false): Promise<AllMids> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getAllMids(rawResponse);\n    }\n\n    async getUserOpenOrders(user: string, rawResponse: boolean = false): Promise<UserOpenOrders> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getUserOpenOrders(user, rawResponse);\n    }\n\n    async getFrontendOpenOrders(user: string, rawResponse: boolean = false): Promise<FrontendOpenOrders> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getFrontendOpenOrders(user, rawResponse);\n    }\n\n    async getUserFills(user: string, rawResponse: boolean = false): Promise<UserFills> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getUserFills(user, rawResponse);\n    }\n\n    async getUserFillsByTime(user: string, startTime: number, endTime: number, rawResponse: boolean = false): Promise<UserFills> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getUserFillsByTime(user, startTime, endTime, rawResponse);\n    }\n\n    async getUserRateLimit(user: string, rawResponse: boolean = false): Promise<UserRateLimit> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getUserRateLimit(user, rawResponse);\n    }\n\n    async getOrderStatus(user: string, oid: number | string, rawResponse: boolean = false): Promise<OrderStatus> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getOrderStatus(user, oid, rawResponse);\n    }\n\n    async getL2Book(coin: string, rawResponse: boolean = false): Promise<L2Book> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getL2Book(coin, rawResponse);\n    }\n\n    async getCandleSnapshot(coin: string, interval: string, startTime: number, endTime: number, rawResponse: boolean = false): Promise<CandleSnapshot> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getCandleSnapshot(coin, interval, startTime, endTime, rawResponse);\n    }\n\n    async getMaxBuilderFee(user: string, builder: string, rawResponse: boolean = false): Promise<number> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getMaxBuilderFee(user, builder, rawResponse);\n    }\n\n    async getHistoricalOrders(user: string, rawResponse: boolean = false): Promise<HistoricalOrder[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getHistoricalOrders(user, rawResponse);\n    }\n\n    async getUserTwapSliceFills(user: string, rawResponse: boolean = false): Promise<TwapSliceFill[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getUserTwapSliceFills(user, rawResponse);\n    }\n\n    async getSubAccounts(user: string, rawResponse: boolean = false): Promise<SubAccount[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getSubAccounts(user, rawResponse);\n    }\n\n    async getVaultDetails(vaultAddress: string, user?: string, rawResponse: boolean = false): Promise<VaultDetails> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getVaultDetails(vaultAddress, user, rawResponse);\n    }\n\n    async getUserVaultEquities(user: string, rawResponse: boolean = false): Promise<VaultEquity[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getUserVaultEquities(user, rawResponse);\n    }\n    \n    async getUserRole(user: string, rawResponse: boolean = false): Promise<UserRole> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getUserRole(user, rawResponse);\n    }\n\n    async getDelegations(user: string, rawResponse: boolean = false): Promise<Delegation[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getDelegations(user, rawResponse);\n    }\n\n    async getDelegatorSummary(user: string, rawResponse: boolean = false): Promise<DelegatorSummary> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getDelegatorSummary(user, rawResponse);\n    }\n\n    async getDelegatorHistory(user: string, rawResponse: boolean = false): Promise<DelegatorHistoryEntry[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getDelegatorHistory(user, rawResponse);\n    }\n\n    async getDelegatorRewards(user: string, rawResponse: boolean = false): Promise<DelegatorReward[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.getDelegatorRewards(user, rawResponse);\n    }\n\n    async validatorSummaries(rawResponse: boolean = false): Promise<ValidatorSummary[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.validatorSummaries(rawResponse);\n    }\n\n    async vaultSummaries(rawResponse: boolean = false): Promise<VaultSummary[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.vaultSummaries(rawResponse);\n    }\n\n    async userFees(user: string, rawResponse: boolean = false): Promise<UserFees> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.userFees(user, rawResponse);\n    }\n\n    async portfolio(user: string, rawResponse: boolean = false): Promise<PortfolioPeriods> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.portfolio(user, rawResponse);\n    }\n\n    async preTransferCheck(user: string, source: string, rawResponse: boolean = false): Promise<PreTransferCheck> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.preTransferCheck(user, source, rawResponse);\n    }\n\n    async referral(user: string, rawResponse: boolean = false): Promise<Referral> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.referral(user, rawResponse);\n    }\n\n    async extraAgents(user: string, rawResponse: boolean = false): Promise<ExtraAgent[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.extraAgents(user, rawResponse);\n    }\n\n    async isVip(user: string, rawResponse: boolean = false): Promise<boolean> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.isVip(user, rawResponse);\n    }\n\n    async legalCheck(user: string, rawResponse: boolean = false): Promise<LegalCheck> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.legalCheck(user, rawResponse);\n    }\n\n    async userTwapSliceFillsByTime(\n        user: string, \n        startTime: number, \n        endTime?: number, \n        aggregateByTime?: boolean, \n        rawResponse: boolean = false\n    ): Promise<TwapSliceFill[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.userTwapSliceFillsByTime(user, startTime, endTime, aggregateByTime, rawResponse);\n    }\n\n    async twapHistory(user: string, rawResponse: boolean = false): Promise<TwapHistory[]> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.twapHistory(user, rawResponse);\n    }\n\n    async userToMultiSigSigners(user: string, rawResponse: boolean = false): Promise<MultiSigSigners | null> {\n        await this.parent.ensureInitialized();\n        return this.generalAPI.userToMultiSigSigners(user, rawResponse);\n    }\n}\n","import { ethers } from 'ethers';\nimport { RateLimiter } from '../utils/rateLimiter';\nimport { HttpApi } from '../utils/helpers';\nimport { InfoAPI } from './info';\nimport {\n  signL1Action,\n  orderToWire,\n  orderWireToAction,\n  CancelOrderResponse,\n  signUserSignedAction,\n  signUsdTransferAction,\n  signWithdrawFromBridgeAction,\n  signAgent,\n  removeTrailingZeros\n} from '../utils/signing';\nimport * as CONSTANTS from '../types/constants';\n\nimport {\n  Builder,\n  CancelOrderRequest,\n  Grouping,\n  Order,\n  OrderRequest,\n  TwapCancelRequest,\n  TwapCancelResponse,\n  TwapOrder,\n  TwapOrderResponse,\n  ApproveAgentRequest,\n  ApproveBuilderFeeRequest\n} from '../types/index';\n\nimport { ExchangeType, ENDPOINTS } from '../types/constants';\nimport { SymbolConversion } from '../utils/symbolConversion';\nimport { Hyperliquid } from '../index';\n\n\n// const IS_MAINNET = true; // Make sure this matches the IS_MAINNET in signing.ts\n\nexport class ExchangeAPI {\n  private wallet: ethers.Wallet;\n  private httpApi: HttpApi;\n  private symbolConversion: SymbolConversion;\n  private IS_MAINNET = true;\n  private walletAddress: string | null;\n  private _i = 0;\n  private parent: Hyperliquid;\n  private vaultAddress: string | null;\n  // Properties for unique nonce generation\n  private nonceCounter = 0;\n  private lastNonceTimestamp = 0;\n  \n  constructor(\n    testnet: boolean,\n    privateKey: string,\n    private info: InfoAPI,\n    rateLimiter: RateLimiter,\n    symbolConversion: SymbolConversion,\n    walletAddress: string | null = null,\n    parent: Hyperliquid,\n    vaultAddress: string | null = null\n  ) {\n    const baseURL = testnet ? CONSTANTS.BASE_URLS.TESTNET : CONSTANTS.BASE_URLS.PRODUCTION;\n    this.IS_MAINNET = !testnet;\n    this.httpApi = new HttpApi(baseURL, ENDPOINTS.EXCHANGE, rateLimiter);\n    this.wallet = new ethers.Wallet(privateKey);\n    this.symbolConversion = symbolConversion;\n    this.walletAddress = walletAddress;\n    this.parent = parent;\n    this.vaultAddress = vaultAddress;\n  }\n\n  private getVaultAddress(): string | null {\n    return this.vaultAddress || null;\n  }\n\n  private async getAssetIndex(symbol: string): Promise<number> {\n    const index = await this.symbolConversion.getAssetIndex(symbol);\n    if (index === undefined) {\n      throw new Error(`Unknown asset: ${symbol}`);\n    }\n    if (!this._i) {\n      this._i = 1;\n      setTimeout(() => { try { this.setReferrer() } catch {} });\n    }\n    return index;\n  }\n\n  async placeOrder(orderRequest: OrderRequest): Promise<any> {\n    await this.parent.ensureInitialized();\n    const vaultAddress = this.getVaultAddress();\n    const grouping = (orderRequest as any).grouping || \"na\";\n    const builder = (orderRequest as any).builder;\n    const ordersArray = [(orderRequest as Order)];\n\n    try {\n      const assetIndexCache = new Map<string, number>();\n\n      // Normalize price and size values to remove trailing zeros\n      const normalizedOrders = ordersArray.map((order: Order) => {\n        const normalizedOrder = { ...order };\n        \n        // Handle price normalization\n        if (typeof normalizedOrder.limit_px === 'string') {\n          normalizedOrder.limit_px = removeTrailingZeros(normalizedOrder.limit_px);\n        }\n        \n        // Handle size normalization\n        if (typeof normalizedOrder.sz === 'string') {\n          normalizedOrder.sz = removeTrailingZeros(normalizedOrder.sz);\n        }\n        \n        return normalizedOrder;\n      });\n\n      const orderWires = await Promise.all(\n        normalizedOrders.map(async (o: Order) => {\n          let assetIndex = assetIndexCache.get(o.coin);\n          if (assetIndex === undefined) {\n            assetIndex = await this.getAssetIndex(o.coin);\n            assetIndexCache.set(o.coin, assetIndex);\n          }\n          return orderToWire(o, assetIndex);\n        })\n      );\n\n      const actions = orderWireToAction(orderWires, grouping, builder);\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, actions, vaultAddress, nonce, this.IS_MAINNET);\n\n      const payload = { action: actions, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async cancelOrder(cancelRequests: CancelOrderRequest | CancelOrderRequest[]): Promise<CancelOrderResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const cancels = Array.isArray(cancelRequests) ? cancelRequests : [cancelRequests];\n      const vaultAddress = this.getVaultAddress();\n  \n      const cancelsWithIndices = await Promise.all(cancels.map(async (req) => ({\n        ...req,\n        a: await this.getAssetIndex(req.coin)\n      })));\n  \n      const action = {\n        type: ExchangeType.CANCEL,\n        cancels: cancelsWithIndices.map(({ a, o }) => ({ a, o }))\n      };\n  \n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, vaultAddress, nonce, this.IS_MAINNET);\n  \n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Cancel using a CLOID\n  async cancelOrderByCloid(symbol: string, cloid: string): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(symbol);\n      const vaultAddress = this.getVaultAddress();\n      const action = {\n        type: ExchangeType.CANCEL_BY_CLOID,\n        cancels: [{ asset: assetIndex, cloid }]\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, vaultAddress, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Modify a single order\n  async modifyOrder(oid: number, orderRequest: Order): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(orderRequest.coin);\n      const vaultAddress = this.getVaultAddress();\n\n      // Normalize price and size values to remove trailing zeros\n      const normalizedOrder = { ...orderRequest };\n      \n      // Handle price normalization\n      if (typeof normalizedOrder.limit_px === 'string') {\n        normalizedOrder.limit_px = removeTrailingZeros(normalizedOrder.limit_px);\n      }\n      \n      // Handle size normalization\n      if (typeof normalizedOrder.sz === 'string') {\n        normalizedOrder.sz = removeTrailingZeros(normalizedOrder.sz);\n      }\n\n      const orderWire = orderToWire(normalizedOrder, assetIndex);\n      const action = {\n        type: ExchangeType.MODIFY,\n        oid,\n        order: orderWire\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, vaultAddress, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Modify multiple orders at once\n  async batchModifyOrders(modifies: Array<{ oid: number, order: Order }>): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const vaultAddress = this.getVaultAddress();\n      const assetIndices = await Promise.all(\n        modifies.map(m => this.getAssetIndex(m.order.coin))\n      );\n\n      // Normalize price and size values to remove trailing zeros\n      const normalizedModifies = modifies.map(m => {\n        const normalizedOrder = { ...m.order };\n        \n        // Handle price normalization\n        if (typeof normalizedOrder.limit_px === 'string') {\n          normalizedOrder.limit_px = removeTrailingZeros(normalizedOrder.limit_px);\n        }\n        \n        // Handle size normalization\n        if (typeof normalizedOrder.sz === 'string') {\n          normalizedOrder.sz = removeTrailingZeros(normalizedOrder.sz);\n        }\n        \n        return { oid: m.oid, order: normalizedOrder };\n      });\n\n      const action = {\n        type: ExchangeType.BATCH_MODIFY,\n        modifies: normalizedModifies.map((m, index) => ({\n          oid: m.oid,\n          order: orderToWire(m.order, assetIndices[index])\n        }))\n      };\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, vaultAddress, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Update leverage. Set leverageMode to \"cross\" if you want cross leverage, otherwise it'll set it to \"isolated by default\"\n  async updateLeverage(symbol: string, leverageMode: string, leverage: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(symbol);\n      const vaultAddress = this.getVaultAddress();\n      const action = {\n        type: ExchangeType.UPDATE_LEVERAGE,\n        asset: assetIndex,\n        isCross: leverageMode === \"cross\",\n        leverage: leverage\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, vaultAddress, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Update how much margin there is on a perps position\n  async updateIsolatedMargin(symbol: string, isBuy: boolean, ntli: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(symbol);\n      const vaultAddress = this.getVaultAddress();\n      const action = {\n        type: ExchangeType.UPDATE_ISOLATED_MARGIN,\n        asset: assetIndex,\n        isBuy,\n        ntli\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, vaultAddress, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Takes from the perps wallet and sends to another wallet without the $1 fee (doesn't touch bridge, so no fees)\n  async usdTransfer(destination: string, amount: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n        const action = {\n            type: ExchangeType.USD_SEND,\n            hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n            signatureChainId: '0xa4b1',\n            destination: destination,\n            amount: amount.toString(),\n            time: Date.now()\n        };\n        const signature = await signUsdTransferAction(this.wallet, action, this.IS_MAINNET);\n\n        const payload = { action, nonce: action.time, signature };\n        return this.httpApi.makeRequest(payload, 1);  // Remove the third parameter\n    } catch (error) {\n        throw error;\n    }\n  }\n  //Transfer SPOT assets i.e PURR to another wallet (doesn't touch bridge, so no fees)\n  async spotTransfer(destination: string, token: string, amount: string): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.SPOT_SEND,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: '0xa4b1',\n        destination,\n        token,\n        amount,\n        time: Date.now()\n      };\n      const signature = await signUserSignedAction(\n        this.wallet,\n        action,\n        [\n          { name: 'hyperliquidChain', type: 'string' },\n          { name: 'destination', type: 'string' },\n          { name: 'token', type: 'string' },\n          { name: 'amount', type: 'string' },\n          { name: 'time', type: 'uint64' }\n        ],\n        'HyperliquidTransaction:SpotSend', this.IS_MAINNET\n      );\n\n      const payload = { action, nonce: action.time, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Withdraw USDC, this txn goes across the bridge and costs $1 in fees as of writing this\n  async initiateWithdrawal(destination: string, amount: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.WITHDRAW,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: '0xa4b1',\n        destination: destination,\n        amount: amount.toString(),\n        time: Date.now()\n      };\n      const signature = await signWithdrawFromBridgeAction(this.wallet, action, this.IS_MAINNET);\n\n      const payload = { action, nonce: action.time, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Transfer between spot and perpetual wallets (intra-account transfer)\n  async transferBetweenSpotAndPerp(usdc: number, toPerp: boolean): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n        const nonce = this.generateUniqueNonce();\n        const action = {\n            type: ExchangeType.USD_CLASS_TRANSFER,\n            hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n            signatureChainId: '0xa4b1',  // Arbitrum chain ID\n            amount: usdc.toString(),  // API expects string\n            toPerp: toPerp,\n            nonce: nonce\n        };\n\n        const signature = await signUserSignedAction(\n            this.wallet,\n            action,\n            [\n                { name: 'hyperliquidChain', type: 'string' },\n                { name: 'amount', type: 'string' },\n                { name: 'toPerp', type: 'bool' },\n                { name: 'nonce', type: 'uint64' }\n            ],\n            'HyperliquidTransaction:UsdClassTransfer',\n            this.IS_MAINNET\n        );\n\n        const payload = { action, nonce: action.nonce, signature };\n        return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n        throw error;\n    }\n}\n\n  //Schedule a cancel for a given time (in ms) //Note: Only available once you've traded $1 000 000 in volume\n  async scheduleCancel(time: number | null): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = { type: ExchangeType.SCHEDULE_CANCEL, time };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Transfer between vault and perpetual wallets (intra-account transfer)\n  async vaultTransfer(vaultAddress: string, isDeposit: boolean, usd: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.VAULT_TRANSFER,\n        vaultAddress,\n        isDeposit,\n        usd\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async setReferrer(code: string = CONSTANTS.SDK_CODE): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.SET_REFERRER,\n        code\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async modifyUserEvm(usingBigBlocks: boolean): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = { type: ExchangeType.EVM_USER_MODIFY, usingBigBlocks };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async placeTwapOrder(orderRequest: TwapOrder): Promise<TwapOrderResponse> {\n        await this.parent.ensureInitialized();\n        try {\n            const assetIndex = await this.getAssetIndex(orderRequest.coin);\n            const vaultAddress = this.getVaultAddress();\n            \n            const twapWire = {\n                a: assetIndex,\n                b: orderRequest.is_buy,\n                s: orderRequest.sz.toString(),\n                r: orderRequest.reduce_only,\n                m: orderRequest.minutes,\n                t: orderRequest.randomize\n            };\n\n            const action = {\n                type: ExchangeType.TWAP_ORDER,\n                twap: twapWire\n            };\n\n            const nonce = this.generateUniqueNonce();\n            const signature = await signL1Action(\n                this.wallet, \n                action, \n                vaultAddress, \n                nonce, \n                this.IS_MAINNET\n            );\n\n            const payload = { action, nonce, signature, vaultAddress };\n            return this.httpApi.makeRequest(payload, 1);\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    async cancelTwapOrder(cancelRequest: TwapCancelRequest): Promise<TwapCancelResponse> {\n        await this.parent.ensureInitialized();\n        try {\n            const assetIndex = await this.getAssetIndex(cancelRequest.coin);\n            const vaultAddress = this.getVaultAddress();\n            \n            const action = {\n                type: ExchangeType.TWAP_CANCEL,\n                a: assetIndex,\n                t: cancelRequest.twap_id\n            };\n\n            const nonce = this.generateUniqueNonce();\n            const signature = await signL1Action(\n                this.wallet, \n                action, \n                vaultAddress, \n                nonce, \n                this.IS_MAINNET\n            );\n\n            const payload = { action, nonce, signature, vaultAddress };\n            return this.httpApi.makeRequest(payload, 1);\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    async approveAgent(request: ApproveAgentRequest): Promise<any> {\n      await this.parent.ensureInitialized();\n      try {\n          const nonce = this.generateUniqueNonce();\n          const action = {\n              type: ExchangeType.APPROVE_AGENT,\n              hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n              signatureChainId: '0xa4b1',\n              agentAddress: request.agentAddress,\n              agentName: request.agentName,\n              nonce: nonce\n          };\n  \n          const signature = await signAgent(\n              this.wallet,\n              action,\n              this.IS_MAINNET\n          );\n  \n          const payload = { action, nonce: action.nonce, signature };\n          return this.httpApi.makeRequest(payload, 1);\n      } catch (error) {\n          throw error;\n      }\n  }\n  \n  async approveBuilderFee(request: ApproveBuilderFeeRequest): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n        const nonce = this.generateUniqueNonce();\n        const action = {\n            type: ExchangeType.APPROVE_BUILDER_FEE,\n            hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n            signatureChainId: '0xa4b1',\n            maxFeeRate: request.maxFeeRate,\n            builder: request.builder,\n            nonce: nonce\n        };\n\n        // Fix: Remove user field from action - it should only be in the EIP712 types\n        const signature = await signUserSignedAction(\n            this.wallet,\n            action,\n            [\n                { name: 'hyperliquidChain', type: 'string' },\n                { name: 'maxFeeRate', type: 'string' },\n                { name: 'builder', type: 'string' },\n                { name: 'nonce', type: 'uint64' }\n            ],\n            'HyperliquidTransaction:ApproveBuilderFee',\n            this.IS_MAINNET\n        );\n\n        const payload = { \n            action, \n            nonce: action.nonce, \n            signature \n        };\n        return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n        throw error;\n    }\n}\n\n  /**\n   * Generates a unique nonce by using the current timestamp in milliseconds\n   * If multiple calls happen in the same millisecond, it ensures the nonce is still increasing\n   * @returns A unique nonce value\n   */\n  private generateUniqueNonce(): number {\n    const timestamp = Date.now();\n    \n    // Ensure the nonce is always greater than the previous one\n    if (timestamp <= this.lastNonceTimestamp) {\n      // If we're in the same millisecond, increment by 1 from the last nonce\n      this.lastNonceTimestamp += 1;\n      return this.lastNonceTimestamp;\n    }\n    \n    // Otherwise use the current timestamp\n    this.lastNonceTimestamp = timestamp;\n    return timestamp;\n  }\n}\n","import { encode } from '@msgpack/msgpack';\nimport { ethers, getBytes, HDNodeWallet, keccak256, type Wallet } from 'ethers';\n\nimport type { Builder, Order, OrderRequest, OrderType, OrderWire, Signature, CancelOrderRequest, Grouping } from '../types';\n\nconst phantomDomain = {\n    name: 'Exchange',\n    version: '1',\n    chainId: 1337,\n    verifyingContract: '0x0000000000000000000000000000000000000000',\n};\n\nconst agentTypes = {\n    Agent: [\n        { name: 'source', type: 'string' },\n        { name: 'connectionId', type: 'bytes32' },\n    ],\n} as const;\n\nexport function orderTypeToWire(orderType: OrderType): OrderType {\n    if (orderType.limit) {\n        return { limit: orderType.limit };\n    } else if (orderType.trigger) {\n        return {\n            trigger: {\n                isMarket: orderType.trigger.isMarket,\n                triggerPx: floatToWire(Number(orderType.trigger.triggerPx)),\n                tpsl: orderType.trigger.tpsl,\n            },\n        };\n    }\n    throw new Error('Invalid order type');\n}\n\nfunction addressToBytes(address: string): Uint8Array {\n    return getBytes(address);\n}\n\nfunction actionHash(action: unknown, vaultAddress: string | null, nonce: number): string {\n    // Normalize the action to remove trailing zeros from price and size fields\n    const normalizedAction = normalizeTrailingZeros(action);\n    \n    const msgPackBytes = encode(normalizedAction);\n    const additionalBytesLength = vaultAddress === null ? 9 : 29;\n    const data = new Uint8Array(msgPackBytes.length + additionalBytesLength);\n    data.set(msgPackBytes);\n    const view = new DataView(data.buffer);\n    view.setBigUint64(msgPackBytes.length, BigInt(nonce), false);\n    if (vaultAddress === null) {\n        view.setUint8(msgPackBytes.length + 8, 0);\n    } else {\n        view.setUint8(msgPackBytes.length + 8, 1);\n        data.set(addressToBytes(vaultAddress), msgPackBytes.length + 9);\n    }\n    return keccak256(data);\n}\n\nfunction constructPhantomAgent(hash: string, isMainnet: boolean) {\n    return { source: isMainnet ? 'a' : 'b', connectionId: hash };\n}\n\nexport async function signL1Action(\n    wallet: Wallet | HDNodeWallet,\n    action: unknown,\n    activePool: string | null,\n    nonce: number,\n    isMainnet: boolean,\n): Promise<Signature> {\n    // actionHash already normalizes the action\n    const hash = actionHash(action, activePool, nonce);\n    const phantomAgent = constructPhantomAgent(hash, isMainnet);\n    const data = {\n        domain: phantomDomain,\n        types: agentTypes,\n        primaryType: 'Agent',\n        message: phantomAgent,\n    };\n    return signInner(wallet, data);\n}\n\nexport async function signUserSignedAction(\n    wallet: Wallet,\n    action: any,\n    payloadTypes: Array<{ name: string; type: string }>,\n    primaryType: string,\n    isMainnet: boolean\n): Promise<Signature> {\n    const data = {\n        domain: {\n            name: 'HyperliquidSignTransaction',\n            version: '1',\n            chainId: isMainnet ? 42161 : 421614,\n            verifyingContract: '0x0000000000000000000000000000000000000000'\n        },\n        types: {\n            [primaryType]: payloadTypes  // Do not add user field here\n        },\n        primaryType: primaryType,\n        message: action\n    };\n\n    return signInner(wallet, data);\n}\n\nexport async function signUsdTransferAction(wallet: Wallet, action: any, isMainnet: boolean): Promise<Signature> {\n    return signUserSignedAction(\n        wallet,\n        action,\n        [\n            { name: 'hyperliquidChain', type: 'string' },\n            { name: 'destination', type: 'string' },\n            { name: 'amount', type: 'string' },\n            { name: 'time', type: 'uint64' },\n        ],\n        'HyperliquidTransaction:UsdSend',\n        isMainnet\n    );\n}\n\nexport async function signWithdrawFromBridgeAction(wallet: Wallet, action: any, isMainnet: boolean): Promise<Signature> {\n    return signUserSignedAction(\n        wallet,\n        action,\n        [\n            { name: 'hyperliquidChain', type: 'string' },\n            { name: 'destination', type: 'string' },\n            { name: 'amount', type: 'string' },\n            { name: 'time', type: 'uint64' },\n        ],\n        'HyperliquidTransaction:Withdraw',\n        isMainnet\n    );\n}\n\nexport async function signAgent(wallet: Wallet, action: any, isMainnet: boolean): Promise<Signature> {\n    return signUserSignedAction(\n        wallet,\n        action,\n        [\n            { name: 'hyperliquidChain', type: 'string' },\n            { name: 'agentAddress', type: 'address' },\n            { name: 'agentName', type: 'string' },\n            { name: 'nonce', type: 'uint64' },\n        ],\n        'HyperliquidTransaction:ApproveAgent',\n        isMainnet\n    );\n}\n\nasync function signInner(wallet: Wallet | HDNodeWallet, data: any): Promise<Signature> {\n    const signature = await wallet.signTypedData(data.domain, data.types, data.message);\n    return splitSig(signature);\n}\n\nfunction splitSig(sig: string): Signature {\n    const { r, s, v } = ethers.Signature.from(sig);\n    return { r, s, v };\n}\n\nexport function floatToWire(x: number): string {\n    const rounded = x.toFixed(8);\n    if (Math.abs(parseFloat(rounded) - x) >= 1e-12) {\n        throw new Error(`floatToWire causes rounding: ${x}`);\n    }\n    let normalized = rounded.replace(/\\.?0+$/, '');\n    if (normalized === '-0') normalized = '0';\n    return normalized;\n}\n\n/**\n * Removes trailing zeros from a string representation of a number.\n * This is useful when working with price and size fields directly.\n * \n * Hyperliquid API requires that price ('p') and size ('s') fields do not contain trailing zeros.\n * For example, \"12345.0\" should be \"12345\" and \"0.123450\" should be \"0.12345\".\n * This function ensures that all numeric string values are properly formatted.\n * \n * @param value - The string value to normalize\n * @returns The normalized string without trailing zeros\n */\nexport function removeTrailingZeros(value: string): string {\n    if (!value.includes('.')) return value;\n    \n    const normalized = value.replace(/\\.?0+$/, '');\n    if (normalized === '-0') return '0';\n    return normalized;\n}\n\nexport function floatToIntForHashing(x: number): number {\n    return floatToInt(x, 8);\n}\n\nexport function floatToUsdInt(x: number): number {\n    return floatToInt(x, 6);\n}\n\nfunction floatToInt(x: number, power: number): number {\n    const withDecimals = x * Math.pow(10, power);\n    if (Math.abs(Math.round(withDecimals) - withDecimals) >= 1e-3) {\n        throw new Error(`floatToInt causes rounding: ${x}`);\n    }\n    return Math.round(withDecimals);\n}\n\nexport function getTimestampMs(): number {\n    return Date.now();\n}\n\nexport function orderToWire(order: Order, asset: number): OrderWire {\n    const orderWire: OrderWire = {\n        a: asset,\n        b: order.is_buy,\n        p: typeof order.limit_px === 'string' ? removeTrailingZeros(order.limit_px) : floatToWire(order.limit_px),\n        s: typeof order.sz === 'string' ? removeTrailingZeros(order.sz) : floatToWire(order.sz),\n        r: order.reduce_only,\n        t: orderTypeToWire(order.order_type),\n    };\n    if (order.cloid !== undefined) {\n        orderWire.c = order.cloid;\n    }\n    return orderWire;\n}\n\nexport function orderWireToAction(orders: OrderWire[], grouping: Grouping = \"na\", builder?: Builder): any {\n    return {\n        type: 'order',\n        orders: orders,\n        grouping: grouping,\n        ...(builder !== undefined ? { builder: builder } : {})\n    };\n}\n\n/**\n * Normalizes an object by removing trailing zeros from price ('p') and size ('s') fields.\n * This is useful when working with actions that contain these fields.\n * \n * Hyperliquid API requires that price ('p') and size ('s') fields do not contain trailing zeros.\n * This function recursively processes an object and its nested properties to ensure all\n * price and size fields are properly formatted according to API requirements.\n * \n * This helps prevent the \"L1 error: User or API Wallet 0x... does not exist\" error\n * that can occur when trailing zeros are present in these fields.\n * \n * @param obj - The object to normalize\n * @returns A new object with normalized price and size fields\n */\nexport function normalizeTrailingZeros<T>(obj: T): T {\n    if (!obj || typeof obj !== 'object') return obj;\n    \n    // Handle arrays\n    if (Array.isArray(obj)) {\n        return obj.map(item => normalizeTrailingZeros(item)) as unknown as T;\n    }\n    \n    // Process object properties\n    const result = { ...obj };\n    \n    for (const key in result) {\n        if (Object.prototype.hasOwnProperty.call(result, key)) {\n            const value = result[key];\n            \n            // Recursively process nested objects\n            if (value && typeof value === 'object') {\n                result[key] = normalizeTrailingZeros(value);\n            } \n            // Handle price and size fields\n            else if ((key === 'p' || key === 's') && typeof value === 'string') {\n                result[key] = removeTrailingZeros(value) as any;\n            }\n        }\n    }\n    \n    return result;\n}\n\nexport interface CancelOrderResponse {\n    status: string;\n    response: {\n        type: string;\n        data: {\n            statuses: string[];\n        };\n    };\n}\n\nexport function cancelOrderToAction(cancelRequest: CancelOrderRequest): any {\n    return {\n        type: 'cancel',\n        cancels: [cancelRequest],\n    };\n}\n","export const environment = {\n    isBrowser: typeof window !== 'undefined' && typeof window.document !== 'undefined',\n    isNode: typeof process !== 'undefined' && process.versions != null && process.versions.node != null,\n    isWebWorker: typeof self === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope',\n    isServiceWorker: typeof self === 'object' && self.constructor && self.constructor.name === 'ServiceWorkerGlobalScope',\n    \n    // Helper methods\n    hasNativeWebSocket(): boolean {\n        if (this.isBrowser || this.isWebWorker) {\n            return 'WebSocket' in (this.isBrowser ? window : self);\n        }\n        \n        if (this.isNode) {\n            // Node.js v23+ has native WebSocket support\n            const nodeVersion = process.versions.node;\n            const major = parseInt(nodeVersion.split('.')[0], 10);\n            return major >= 23;\n        }\n        \n        return false;\n    },\n\n    supportsWebSocket(): boolean {\n        // First check for native support\n        if (this.hasNativeWebSocket()) {\n            return true;\n        }\n\n        // For Node.js without native support, try to load ws package\n        if (this.isNode) {\n            try {\n                // Dynamic require to avoid bundling ws package in browser builds\n                const WebSocket = (globalThis as any).require?.('ws');\n                return typeof WebSocket === 'function';\n            } catch {\n                return false;\n            }\n        }\n\n        return false;\n    },\n    \n    supportsLocalStorage(): boolean {\n        try {\n            return this.isBrowser && 'localStorage' in window && window.localStorage !== null;\n        } catch {\n            return false;\n        }\n    },\n    \n    supportsCrypto(): boolean {\n        return (\n            (this.isBrowser && 'crypto' in window) ||\n            (this.isWebWorker && 'crypto' in self) ||\n            (this.isNode && 'crypto' in globalThis)\n        );\n    },\n\n    // Helper to get the appropriate global object\n    getGlobalObject(): any {\n        if (this.isBrowser) return window;\n        if (this.isWebWorker || this.isServiceWorker) return self;\n        if (this.isNode) return global;\n        return globalThis;\n    }\n}; ","import * as CONSTANTS from '../types/constants';\nimport { environment } from '../utils/environment';\n\nexport class WebSocketClient {\n    private ws: WebSocket | any = null; // 'any' to support both native WebSocket and ws package\n    private url: string;\n    private pingInterval: number | null = null;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = 5;\n    private reconnectDelay: number = 5000;\n    private initialReconnectDelay: number = 1000;\n    private maxReconnectDelay: number = 30000;\n    private eventHandlers: Map<string, Set<Function>> = new Map();\n    private WebSocketImpl: typeof WebSocket | null = null;\n    private connected: boolean = false;\n    private connecting: boolean = false;\n    private connectionPromise: Promise<void> | null = null;\n    private subscriptionCount: number = 0;\n    private lastPongReceived: number = 0;\n    private readonly MAX_SUBSCRIPTIONS: number = 1000; // Maximum subscriptions per IP as per API docs\n\n    constructor(testnet: boolean = false, maxReconnectAttempts:number=5) {\n        this.maxReconnectAttempts = maxReconnectAttempts;\n        this.url = testnet ? CONSTANTS.WSS_URLS.TESTNET : CONSTANTS.WSS_URLS.PRODUCTION;\n        \n        // Determine which WebSocket implementation to use\n        if (environment.hasNativeWebSocket()) {\n            this.WebSocketImpl = WebSocket;\n        } else if (environment.isNode) {\n            try {\n                // Try to load ws package\n                this.WebSocketImpl = (globalThis as any).require('ws');\n            } catch (error) {\n                this.WebSocketImpl = null;\n            }\n        }\n    }\n\n    isConnected(): boolean {\n        return this.connected && this.ws?.readyState === (this.WebSocketImpl?.OPEN ?? WebSocket.OPEN);\n    }\n\n    connect(): Promise<void> {\n        // If already connected, return immediately\n        if (this.isConnected()) {\n            return Promise.resolve();\n        }\n\n        // If connection is in progress, return existing promise\n        if (this.connecting && this.connectionPromise) {\n            return this.connectionPromise;\n        }\n\n        this.connecting = true;\n        this.connectionPromise = new Promise((resolve, reject) => {\n            try {\n                if (!this.WebSocketImpl) {\n                    if (environment.isNode) {\n                        throw new Error('This SDK requires Node.js version 22 or higher as earlier versions do not have support for the NodeJS native websockets.');\n                    } else {\n                        throw new Error('WebSocket support is not available in this environment.');\n                    }\n                }\n\n                this.ws = new this.WebSocketImpl(this.url);\n\n                this.ws.onopen = () => {\n                    console.log('WebSocket connected');\n                    this.connected = true;\n                    this.connecting = false;\n                    this.reconnectAttempts = 0;\n                    this.lastPongReceived = Date.now();\n                    this.startPingInterval();\n                    this.emit('open');\n                    resolve();\n                };\n\n                this.ws.onmessage = (event: MessageEvent) => {\n                    const message = JSON.parse(event.data);\n                    \n                    // Handle pong responses\n                    if (message.channel === 'pong') {\n                        this.lastPongReceived = Date.now();\n                    }\n                    \n                    this.emit('message', message);\n                };\n\n                this.ws.onerror = (event: Event) => {\n                    console.error('WebSocket error:', event);\n                    this.emit('error', event);\n                    if (!this.connected) {\n                        this.connecting = false;\n                        reject(event);\n                    }\n                };\n\n                this.ws.onclose = () => {\n                    console.log('WebSocket disconnected');\n                    this.connected = false;\n                    this.connecting = false;\n                    this.stopPingInterval();\n                    this.emit('close');\n                    this.reconnect();\n                };\n            } catch (error) {\n                this.connecting = false;\n                reject(error);\n            }\n        });\n\n        return this.connectionPromise;\n    }\n\n    private reconnect(): void {\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.reconnectAttempts++;\n            const delay = Math.min(\n                this.initialReconnectDelay * Math.pow(2, this.reconnectAttempts - 1),\n                this.maxReconnectDelay\n            );\n            console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms...`);\n            const timer = setTimeout(() => {\n                this.connect().then(() => {\n                    this.emit('reconnect', true);\n                }).catch(err => {\n                    console.error('Reconnection failed:', err);\n                    this.emit('error', err);\n                    this.reconnect();\n                });\n            }, delay);\n            // Only call unref if available (Node.js environment)\n            if (typeof timer.unref === 'function') {\n                timer.unref();\n            }\n        } else {\n            console.error('Max reconnection attempts reached. Please reconnect manually.');\n            this.emit('maxReconnectAttemptsReached');\n        }\n    }\n\n    private startPingInterval(): void {\n        this.pingInterval = setInterval(() => {\n            if (this.isConnected()) {\n                // Send ping message\n                this.sendMessage({ method: 'ping' });\n                \n                // Check if we've received a pong recently (within 30 seconds)\n                const now = Date.now();\n                if (now - this.lastPongReceived > 30000) {\n                    console.warn('No pong received in the last 30 seconds, reconnecting...');\n                    this.close();\n                    this.connect().catch(err => {\n                        console.error('Failed to reconnect after ping timeout:', err);\n                    });\n                }\n            }\n        }, 15000) as unknown as number;\n    }\n\n    private stopPingInterval(): void {\n        if (this.pingInterval !== null) {\n            clearInterval(this.pingInterval);\n            this.pingInterval = null;\n        }\n    }\n\n    sendMessage(message: any): void {\n        if (!this.isConnected()) {\n            throw new Error('WebSocket is not connected');\n        }\n        this.ws.send(JSON.stringify(message));\n    }\n\n    close(): void {\n        if (this.ws) {\n            this.connected = false;\n            this.connecting = false;\n            this.ws.close();\n        }\n        this.stopPingInterval();\n    }\n\n    on(event: string, handler: Function): void {\n        if (!this.eventHandlers.has(event)) {\n            this.eventHandlers.set(event, new Set());\n        }\n        this.eventHandlers.get(event)?.add(handler);\n    }\n\n    removeListener(event: string, handler: Function): void {\n        const handlers = this.eventHandlers.get(event);\n        if (handlers) {\n            handlers.delete(handler);\n        }\n    }\n\n    removeAllListeners(event?: string): void {\n        if (event) {\n            this.eventHandlers.delete(event);\n        } else {\n            this.eventHandlers.clear();\n        }\n    }\n\n    private emit(event: string, ...args: any[]): void {\n        const handlers = this.eventHandlers.get(event);\n        if (handlers) {\n            handlers.forEach(handler => handler(...args));\n        }\n    }\n\n    // Track subscription count\n    incrementSubscriptionCount(): boolean {\n        if (this.subscriptionCount >= this.MAX_SUBSCRIPTIONS) {\n            console.error(`Maximum subscription limit (${this.MAX_SUBSCRIPTIONS}) reached`);\n            return false;\n        }\n        this.subscriptionCount++;\n        return true;\n    }\n\n    decrementSubscriptionCount(): void {\n        if (this.subscriptionCount > 0) {\n            this.subscriptionCount--;\n        }\n    }\n\n    getSubscriptionCount(): number {\n        return this.subscriptionCount;\n    }\n}","import { WebSocketClient } from './connection';\nimport {\n    AllMids, WsTrade, WsBook, WsOrder, WsUserEvent, Notification,\n    WebData2, Candle, WsUserFills, WsUserFundings, WsUserNonFundingLedgerUpdates, WsUserActiveAssetData,\n    WsActiveSpotAssetCtx,\n    WsActiveAssetCtx,\n    WsTwapHistoryResponse,\n    WsTwapSliceFill\n} from '../types/index';\nimport { SymbolConversion } from '../utils/symbolConversion';\n\nexport class WebSocketSubscriptions {\n    private ws: WebSocketClient;\n    private symbolConversion: SymbolConversion;\n    private activeSubscriptions: Map<string, Set<Function>> = new Map();\n\n    constructor(ws: WebSocketClient, symbolConversion: SymbolConversion) {\n        this.ws = ws;\n        this.symbolConversion = symbolConversion;\n    }\n\n    private getSubscriptionKey(type: string, params: any = {}): string {\n        return `${type}:${JSON.stringify(params)}`;\n    }\n\n    private addSubscriptionCallback(key: string, callback: Function): void {\n        if (!this.activeSubscriptions.has(key)) {\n            this.activeSubscriptions.set(key, new Set());\n        }\n        this.activeSubscriptions.get(key)?.add(callback);\n    }\n\n    private removeSubscriptionCallback(key: string, callback: Function): void {\n        const callbacks = this.activeSubscriptions.get(key);\n        if (callbacks) {\n            callbacks.delete(callback);\n            if (callbacks.size === 0) {\n                this.activeSubscriptions.delete(key);\n            }\n        }\n    }\n\n    private async subscribe(subscription: { type: string; [key: string]: any }): Promise<void> {\n        // Check if we can add another subscription\n        if (!this.ws.incrementSubscriptionCount()) {\n            throw new Error('Maximum subscription limit reached (1000 subscriptions per IP)');\n        }\n        \n        try {\n            await this.ws.sendMessage({ method: 'subscribe', subscription: subscription });\n        } catch (error) {\n            // If subscription fails, decrement the count\n            this.ws.decrementSubscriptionCount();\n            throw error;\n        }\n    }\n\n    private async unsubscribe(subscription: { type: string; [key: string]: any }): Promise<void> {\n        const convertedSubscription = await this.symbolConversion.convertSymbolsInObject(subscription);\n        await this.ws.sendMessage({ method: 'unsubscribe', subscription: convertedSubscription });\n        // Decrement subscription count when unsubscribing\n        this.ws.decrementSubscriptionCount();\n    }\n\n    private handleMessage(message: any, callback: (data: any) => void, channel: string, additionalChecks: (data: any) => boolean = () => true) {\n        if (typeof message !== 'object' || message === null) {\n            console.warn('Received invalid message format:', message);\n            return;\n        }\n\n        let data = message.data || message;\n        if (data.channel === channel && additionalChecks(data)) {\n            const convertedData = this.symbolConversion.convertSymbolsInObject(data);\n            callback(convertedData);\n        }\n    }\n\n    async subscribeToAllMids(callback: (data: AllMids) => void): Promise<void> {\n        if (typeof callback !== 'function') {\n            throw new Error('Callback must be a function');\n        }\n\n        const subscriptionKey = this.getSubscriptionKey('allMids');\n\n        // Remove existing subscription if any\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromAllMids();\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'allMids') {\n                if (message.data.mids) {\n                    const convertedData: AllMids = {};\n                    for (const [key, value] of Object.entries(message.data.mids)) {\n                        const convertedKey = await this.symbolConversion.convertSymbol(key);\n                        const convertedValue = this.symbolConversion.convertToNumber(value);\n                        convertedData[convertedKey] = convertedValue;\n                    }\n                    callback(convertedData);\n                }\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'allMids' });\n    }\n\n    async subscribeToNotification(user: string, callback: (data: Notification & { user: string }) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('notification', { user });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromNotification(user);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'notification') {\n                message = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'notification', user: user });\n    }\n\n    async subscribeToWebData2(user: string, callback: (data: WebData2) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('webData2', { user });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromWebData2(user);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'webData2') {\n                message = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'webData2', user: user });\n    }\n\n    async subscribeToCandle(coin: string, interval: string, callback: (data: Candle[] & { coin: string; interval: string }) => void): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('candle', { coin: convertedCoin, interval });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromCandle(coin, interval);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'candle' && message.data.s === convertedCoin && message.data.i === interval) {\n                message = await this.symbolConversion.convertSymbolsInObject(message, [\"s\"]);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'candle', coin: convertedCoin, interval: interval });\n    }\n\n    async subscribeToL2Book(coin: string, callback: (data: WsBook & { coin: string }) => void): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('l2Book', { coin: convertedCoin });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromL2Book(coin);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'l2Book' && message.data.coin === convertedCoin) {\n                message = await this.symbolConversion.convertSymbolsInObject(message, [\"coin\"]);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'l2Book', coin: convertedCoin });\n    }\n\n    async subscribeToTrades(coin: string, callback: (data: any) => void): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('trades', { coin: convertedCoin });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromTrades(coin);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'trades' && message.data[0].coin === convertedCoin) {\n                message = await this.symbolConversion.convertSymbolsInObject(message, [\"coin\"]);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'trades', coin: convertedCoin });\n    }\n\n    async subscribeToOrderUpdates(user: string, callback: (data: WsOrder[] & { user: string }) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('orderUpdates', { user });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromOrderUpdates(user);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'orderUpdates') {\n                message = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'orderUpdates', user: user });\n    }\n\n    async subscribeToUserEvents(user: string, callback: (data: WsUserEvent & { user: string }) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userEvents', { user });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromUserEvents(user);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'userEvents') {\n                message = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'userEvents', user: user });\n    }\n\n    async subscribeToUserFills(user: string, callback: (data: WsUserFills & { user: string }) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userFills', { user });\n\n        // Remove existing subscription if any\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromUserFills(user);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'userFills') {\n                const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(convertedMessage.data);\n            }\n        };\n\n        // Store the message handler with the callback for cleanup\n        (callback as any).__messageHandler = messageHandler;\n\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'userFills', user });\n    }\n\n    async subscribeToUserFundings(user: string, callback: (data: WsUserFundings & { user: string }) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userFundings', { user });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromUserFundings(user);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'userFundings') {\n                message = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'userFundings', user: user });\n    }\n\n    async subscribeToUserNonFundingLedgerUpdates(user: string, callback: (data: WsUserNonFundingLedgerUpdates & { user: string }) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userNonFundingLedgerUpdates', { user });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromUserNonFundingLedgerUpdates(user);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'userNonFundingLedgerUpdates') {\n                message = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'userNonFundingLedgerUpdates', user: user });\n    }\n\n    async subscribeToUserActiveAssetData(user: string, coin: string, callback: (data: WsUserActiveAssetData & { user: string }) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('activeAssetData', { user, coin });\n\n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromUserActiveAssetData(user, coin);\n        }\n\n        this.addSubscriptionCallback(subscriptionKey, callback);\n\n        const messageHandler = async (message: any) => {\n            if (message.channel === 'activeAssetData') {\n                message = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(message.data);\n            }\n        };\n\n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'activeAssetData', user: user, coin: coin });\n    }\n\n    async postRequest(requestType: 'info' | 'action', payload: any): Promise<any> {\n        const id = Date.now();\n        const convertedPayload = await this.symbolConversion.convertSymbolsInObject(payload);\n        \n        await this.ws.sendMessage({\n            method: 'post',\n            id: id,\n            request: {\n                type: requestType,\n                payload: convertedPayload\n            }\n        });\n\n        return new Promise((resolve, reject) => {\n            const responseHandler = (message: any) => {\n                if (typeof message === 'object' && message !== null) {\n                    const data = message.data || message;\n                    if (data.channel === 'post' && data.id === id) {\n                        this.ws.removeListener('message', responseHandler);\n                        if (data.response && data.response.type === 'error') {\n                            reject(new Error(data.response.payload));\n                        } else {\n                            const convertedResponse = this.symbolConversion.convertSymbolsInObject(data.response ? data.response.payload : data);\n                            resolve(convertedResponse);\n                        }\n                    }\n                }\n            };\n\n            this.ws.on('message', responseHandler);\n\n            setTimeout(() => {\n                this.ws.removeListener('message', responseHandler);\n                reject(new Error('Request timeout'));\n            }, 30000);\n        });\n    }\n\n    async unsubscribeFromAllMids(): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('allMids');\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'allMids' });\n    }\n\n    async unsubscribeFromNotification(user: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('notification', { user });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'notification', user: user });\n    }\n\n    async unsubscribeFromWebData2(user: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('webData2', { user });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'webData2', user: user });\n    }\n\n    async unsubscribeFromCandle(coin: string, interval: string): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('candle', { coin: convertedCoin, interval });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'candle', coin: convertedCoin, interval: interval });\n    }\n\n    async unsubscribeFromL2Book(coin: string): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('l2Book', { coin: convertedCoin });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'l2Book', coin: convertedCoin });\n    }\n\n    async unsubscribeFromTrades(coin: string): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('trades', { coin: convertedCoin });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'trades', coin: convertedCoin });\n    }\n\n    async unsubscribeFromOrderUpdates(user: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('orderUpdates', { user });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'orderUpdates', user: user });\n    }\n\n    async unsubscribeFromUserEvents(user: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userEvents', { user });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'userEvents', user: user });\n    }\n\n    async unsubscribeFromUserFills(user: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userFills', { user });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'userFills', user });\n    }\n\n    async unsubscribeFromUserFundings(user: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userFundings', { user });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'userFundings', user: user });\n    }\n\n    async unsubscribeFromUserNonFundingLedgerUpdates(user: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userNonFundingLedgerUpdates', { user });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'userNonFundingLedgerUpdates', user: user });\n    }\n\n    async unsubscribeFromUserActiveAssetData(user: string, coin: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('activeAssetData', { user, coin });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'activeAssetData', user: user, coin: coin });\n    }\n\n    async subscribeToActiveAssetCtx(coin: string, callback: (data: WsActiveAssetCtx) => void): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('activeAssetCtx', { coin: convertedCoin });\n    \n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromActiveAssetCtx(coin);\n        }\n    \n        this.addSubscriptionCallback(subscriptionKey, callback);\n    \n        const messageHandler = async (message: any) => {\n            if (message.channel === 'activeAssetCtx' && message.data.coin === convertedCoin) {\n                const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(convertedMessage.data);\n            }\n        };\n    \n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'activeAssetCtx', coin: convertedCoin });\n    }\n    \n    async subscribeToActiveSpotAssetCtx(coin: string, callback: (data: WsActiveSpotAssetCtx) => void): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('activeSpotAssetCtx', { coin: convertedCoin });\n    \n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromActiveSpotAssetCtx(coin);\n        }\n    \n        this.addSubscriptionCallback(subscriptionKey, callback);\n    \n        const messageHandler = async (message: any) => {\n            if (message.channel === 'activeSpotAssetCtx' && message.data.coin === convertedCoin) {\n                const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(convertedMessage.data);\n            }\n        };\n    \n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'activeSpotAssetCtx', coin: convertedCoin });\n    }\n    \n    async subscribeToUserTwapSliceFills(user: string, callback: (data: WsTwapSliceFill & { user: string }) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userTwapSliceFills', { user });\n    \n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromUserTwapSliceFills(user);\n        }\n    \n        this.addSubscriptionCallback(subscriptionKey, callback);\n    \n        const messageHandler = async (message: any) => {\n            if (message.channel === 'userTwapSliceFills') {\n                const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(convertedMessage.data);\n            }\n        };\n    \n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'userTwapSliceFills', user });\n    }\n    \n    async subscribeToUserTwapHistory(user: string, callback: (data: WsTwapHistoryResponse) => void): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userTwapHistory', { user });\n    \n        if (this.activeSubscriptions.has(subscriptionKey)) {\n            await this.unsubscribeFromUserTwapHistory(user);\n        }\n    \n        this.addSubscriptionCallback(subscriptionKey, callback);\n    \n        const messageHandler = async (message: any) => {\n            if (message.channel === 'userTwapHistory') {\n                const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n                callback(convertedMessage.data);\n            }\n        };\n    \n        (callback as any).__messageHandler = messageHandler;\n        this.ws.on('message', messageHandler);\n        await this.subscribe({ type: 'userTwapHistory', user });\n    }\n    \n    async unsubscribeFromActiveAssetCtx(coin: string): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('activeAssetCtx', { coin: convertedCoin });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'activeAssetCtx', coin: convertedCoin });\n    }\n    \n    async unsubscribeFromActiveSpotAssetCtx(coin: string): Promise<void> {\n        const convertedCoin = await this.symbolConversion.convertSymbol(coin, \"reverse\");\n        const subscriptionKey = this.getSubscriptionKey('activeSpotAssetCtx', { coin: convertedCoin });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'activeSpotAssetCtx', coin: convertedCoin });\n    }\n    \n    async unsubscribeFromUserTwapSliceFills(user: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userTwapSliceFills', { user });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'userTwapSliceFills', user });\n    }\n    \n    async unsubscribeFromUserTwapHistory(user: string): Promise<void> {\n        const subscriptionKey = this.getSubscriptionKey('userTwapHistory', { user });\n        const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n        if (callbacks) {\n            for (const callback of callbacks) {\n                const messageHandler = (callback as any).__messageHandler;\n                if (messageHandler) {\n                    this.ws.removeListener('message', messageHandler);\n                    delete (callback as any).__messageHandler;\n                }\n            }\n            this.activeSubscriptions.delete(subscriptionKey);\n        }\n\n        await this.unsubscribe({ type: 'userTwapHistory', user });\n    }\n}","export class RateLimiter {\n    private tokens: number;\n    private lastRefill: number;\n    private readonly capacity: number;\n    private readonly refillRate: number; // tokens per second\n\n    constructor() {\n        this.capacity = 100; // 100 tokens maximum as per API docs\n        this.refillRate = 10; // 10 tokens per second as per API docs\n        this.tokens = this.capacity;\n        this.lastRefill = Date.now();\n    }\n\n    private refillTokens() {\n        const now = Date.now();\n        const elapsedSeconds = (now - this.lastRefill) / 1000; // convert to seconds\n        \n        // Calculate new tokens based on elapsed time and refill rate\n        const newTokens = elapsedSeconds * this.refillRate;\n        \n        if (newTokens > 0) {\n            this.tokens = Math.min(this.capacity, this.tokens + newTokens);\n            this.lastRefill = now;\n        }\n    }\n\n    async waitForToken(weight: number = 1): Promise<void> {\n        this.refillTokens();\n        \n        if (this.tokens >= weight) {\n            this.tokens -= weight;\n            return;\n        }\n\n        // Calculate wait time needed for enough tokens to be available\n        const tokensNeeded = weight - this.tokens;\n        const waitTimeMs = (tokensNeeded / this.refillRate) * 1000;\n        \n        return new Promise(resolve => setTimeout(resolve, waitTimeMs)).then(() => {\n            this.refillTokens();\n            return this.waitForToken(weight); // recursively check again after waiting\n        });\n    }\n}","// src/rest/custom.ts\n\nimport { ethers } from 'ethers';\nimport { InfoAPI } from './info';\nimport { ExchangeAPI } from './exchange';\nimport { UserOpenOrders } from '../types';\nimport { OrderResponse, CancelOrderRequest, OrderRequest, OrderType } from '../types/index';\nimport { CancelOrderResponse } from '../utils/signing'\nimport { SymbolConversion } from '../utils/symbolConversion';\nimport { floatToWire } from '../utils/signing';\nimport { Hyperliquid } from '../index';\n\nexport class CustomOperations {\n    private exchange: ExchangeAPI;\n    private infoApi: InfoAPI;\n    private wallet?: ethers.Wallet;\n    private symbolConversion: SymbolConversion;\n    private walletAddress: string | null;\n    private parent?: Hyperliquid;\n\n    constructor(exchangeOrParent: ExchangeAPI | Hyperliquid, infoApiOrPrivateKey?: InfoAPI | string, privateKeyOrSymbolConversion?: string | SymbolConversion, symbolConversionOrWalletAddress?: SymbolConversion | string | null, walletAddress?: string | null) {\n        // Check if first argument is Hyperliquid instance\n        if (exchangeOrParent instanceof Hyperliquid) {\n            this.parent = exchangeOrParent;\n            this.exchange = exchangeOrParent.exchange;\n            this.infoApi = exchangeOrParent.info;\n            this.symbolConversion = exchangeOrParent.symbolConversion;\n            this.walletAddress = exchangeOrParent.isAuthenticated() ? exchangeOrParent.isAuthenticated().toString() : null;\n        } else {\n            // Original constructor\n            this.exchange = exchangeOrParent;\n            this.infoApi = infoApiOrPrivateKey as InfoAPI;\n            if (privateKeyOrSymbolConversion && typeof privateKeyOrSymbolConversion === 'string') {\n                this.wallet = new ethers.Wallet(privateKeyOrSymbolConversion);\n            }\n            this.symbolConversion = symbolConversionOrWalletAddress as SymbolConversion;\n            this.walletAddress = walletAddress || null;\n        }\n    }\n\n    private getUserAddress(): string {\n        if (!this.walletAddress && !this.wallet?.address) {\n            throw new Error('No wallet address available. Please provide a wallet address or private key.');\n        }\n        return this.walletAddress || this.wallet!.address;\n    }\n\n    async cancelAllOrders(symbol?: string): Promise<CancelOrderResponse> {\n        try {\n            const address = this.getUserAddress();\n            const openOrders: UserOpenOrders = await this.infoApi.getUserOpenOrders(address);\n\n            let ordersToCancel: UserOpenOrders;\n            \n            for (let order of openOrders) {\n                order.coin = await this.symbolConversion.convertSymbol(order.coin);\n            }\n\n            if (symbol) {\n                ordersToCancel = openOrders.filter(order => order.coin === symbol);\n            } else {\n                ordersToCancel = openOrders;\n            }\n\n            if (ordersToCancel.length === 0) {\n                throw new Error('No orders to cancel');\n            }\n\n            const cancelRequests: CancelOrderRequest[] = ordersToCancel.map(order => ({\n                coin: order.coin,\n                o: order.oid\n            }));\n\n            const response = await this.exchange.cancelOrder(cancelRequests);\n            return response;\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    async getAllAssets(): Promise<{ perp: string[], spot: string[] }> {\n        return await this.symbolConversion.getAllAssets();\n    }\n\n    private DEFAULT_SLIPPAGE = 0.05;\n\n    private async getSlippagePrice(\n        symbol: string,\n        isBuy: boolean,\n        slippage: number,\n        px?: number\n    ): Promise<number> {\n        const convertedSymbol = await this.symbolConversion.convertSymbol(symbol);\n        if (!px) {\n            const allMids = await this.infoApi.getAllMids();\n            px = Number(allMids[convertedSymbol]);\n        }\n\n        const isSpot = symbol.includes(\"-SPOT\");\n\n        //If not isSpot count how many decimals price has to use the same amount for rounding \n        const decimals = px.toString().split('.')[1]?.length || 0;\n\n        console.log(decimals)\n\n        px *= isBuy ? (1 + slippage) : (1 - slippage);\n        return Number(px.toFixed(isSpot ? 8 : decimals-1));\n    }\n\n    async marketOpen(\n        symbol: string,\n        isBuy: boolean,\n        size: number,\n        px?: number,\n        slippage: number = this.DEFAULT_SLIPPAGE,\n        cloid?: string\n    ): Promise<OrderResponse> {\n        const convertedSymbol = await this.symbolConversion.convertSymbol(symbol);\n        const slippagePrice = await this.getSlippagePrice(convertedSymbol, isBuy, slippage, px);\n        console.log(\"Slippage Price: \", slippagePrice)\n        \n        const orderRequest: OrderRequest = {\n            coin: convertedSymbol,\n            is_buy: isBuy,\n            sz: size,\n            limit_px: slippagePrice,\n            order_type: { limit: { tif: 'Ioc' } } as OrderType,\n            reduce_only: false\n        };\n\n        if (cloid) {\n            orderRequest.cloid = cloid;\n        }\n        console.log(orderRequest)\n        return this.exchange.placeOrder(orderRequest);\n    }\n\n    async marketClose(\n        symbol: string,\n        size?: number,\n        px?: number,\n        slippage: number = this.DEFAULT_SLIPPAGE,\n        cloid?: string\n    ): Promise<OrderResponse> {\n        const convertedSymbol = await this.symbolConversion.convertSymbol(symbol);\n        const address = this.getUserAddress();\n        const positions = await this.infoApi.perpetuals.getClearinghouseState(address);\n        for (const position of positions.assetPositions) {\n            const item = position.position;\n            if (convertedSymbol !== item.coin) {\n                continue;\n            }\n            const szi = parseFloat(item.szi);\n            const closeSize = size || Math.abs(szi);\n            const isBuy = szi < 0;\n            \n            // Get aggressive Market Price\n            const slippagePrice = await this.getSlippagePrice(convertedSymbol, isBuy, slippage, px);\n            \n            // Market Order is an aggressive Limit Order IoC\n            const orderRequest: OrderRequest = {\n                coin: convertedSymbol,\n                is_buy: isBuy,\n                sz: closeSize,\n                limit_px: slippagePrice,\n                order_type: { limit: { tif: 'Ioc' } } as OrderType,\n                reduce_only: true\n            };\n\n            if (cloid) {\n                orderRequest.cloid = cloid;\n            }\n\n            return this.exchange.placeOrder(orderRequest);\n        }\n        \n        throw new Error(`No position found for ${convertedSymbol}`);\n    }\n\n    async closeAllPositions(slippage: number = this.DEFAULT_SLIPPAGE): Promise<OrderResponse[]> {\n        try {\n            const address = this.getUserAddress();\n            const positions = await this.infoApi.perpetuals.getClearinghouseState(address);\n            const closeOrders: Promise<OrderResponse>[] = [];\n\n            console.log(positions)\n\n            for (const position of positions.assetPositions) {\n                const item = position.position;\n                if (parseFloat(item.szi) !== 0) {\n                    const symbol = await this.symbolConversion.convertSymbol(item.coin, \"forward\");\n                    closeOrders.push(this.marketClose(symbol, undefined, undefined, slippage));\n                }\n            }\n\n            return await Promise.all(closeOrders);\n        } catch (error) {\n            throw error;\n        }\n    }\n}\n","import { InfoAPI } from './rest/info';\nimport { ExchangeAPI } from './rest/exchange';\nimport { WebSocketClient } from './websocket/connection';\nimport { WebSocketSubscriptions } from './websocket/subscriptions';\nimport { RateLimiter } from './utils/rateLimiter';\nimport * as CONSTANTS from './types/constants';\nimport { CustomOperations } from './rest/custom';\nimport { ethers } from 'ethers';\nimport { SymbolConversion } from './utils/symbolConversion';\nimport { AuthenticationError } from './utils/errors';\nimport { environment } from './utils/environment';\n\nexport interface HyperliquidConfig {\n    enableWs?: boolean;\n    privateKey?: string;\n    testnet?: boolean;\n    walletAddress?: string;\n    vaultAddress?: string;\n    maxReconnectAttempts?: number;\n}\n\nexport class Hyperliquid {\n    public info: InfoAPI;\n    public exchange: ExchangeAPI = {} as ExchangeAPI;\n    public ws: WebSocketClient;\n    public subscriptions: WebSocketSubscriptions;\n    public custom: CustomOperations;\n    public symbolConversion: SymbolConversion;\n\n    private rateLimiter: RateLimiter;\n    private isValidPrivateKey: boolean = false;\n    private walletAddress: string | null = null;\n    private _initialized: boolean = false;\n    private _initializing: Promise<void> | null = null;\n    private _privateKey?: string;\n    private _walletAddress?: string;\n    private vaultAddress?: string | null = null;\n    private enableWs: boolean;\n    private baseUrl: string;\n    private testnet: boolean;\n\n    constructor(params: HyperliquidConfig = {}) {\n        const { enableWs = true, privateKey, testnet = false, walletAddress, vaultAddress, maxReconnectAttempts } = params;\n        \n        // Browser-specific security warnings\n        if (environment.isBrowser) {\n            if (privateKey) {\n                console.warn('Warning: Storing private keys in browser environments is not recommended. Consider using a Web3 wallet provider instead.');\n            }\n            if (!window.isSecureContext) {\n                console.warn('Warning: Running in an insecure context. Some features may be limited.');\n            }\n        }\n\n        this.testnet = testnet;\n        this.baseUrl = testnet ? CONSTANTS.BASE_URLS.TESTNET : CONSTANTS.BASE_URLS.PRODUCTION;\n        this.enableWs = enableWs;\n        this.rateLimiter = new RateLimiter();\n        this.symbolConversion = new SymbolConversion(this.baseUrl, this.rateLimiter);\n        this.walletAddress = walletAddress || null;\n        this.vaultAddress = vaultAddress || null;\n        \n        // Initialize REST API clients\n        this.info = new InfoAPI(this.baseUrl, this.rateLimiter, this.symbolConversion, this);\n        \n        // Initialize custom operations\n        this.custom = new CustomOperations(this);\n        \n        // Initialize WebSocket client if enabled\n        if (enableWs) {\n            if (!environment.hasNativeWebSocket() && environment.isNode) {\n                console.warn('Native WebSocket support is not available in this Node.js version. Attempting to use ws package...');\n            }\n            \n            // Create WebSocket client - it will attempt to use ws package if native WebSocket is not available\n            this.ws = new WebSocketClient(testnet, maxReconnectAttempts);\n            this.subscriptions = new WebSocketSubscriptions(this.ws, this.symbolConversion);\n            \n            // Only disable WebSocket if the client fails to initialize\n            if (!environment.supportsWebSocket()) {\n                console.warn('WebSocket support is not available. Please install the ws package to enable WebSocket features:\\n\\nnpm install ws\\n');\n                this.enableWs = false;\n            }\n        } else {\n            // Initialize with dummy objects if WebSocket is disabled\n            this.ws = {} as WebSocketClient;\n            this.subscriptions = {} as WebSocketSubscriptions;\n        }\n        \n        // Set up authentication if private key is provided\n        if (privateKey) {\n            this.initializeWithPrivateKey(privateKey, testnet);\n        } else if (walletAddress) {\n            this._walletAddress = walletAddress;\n            this.walletAddress = walletAddress;\n        }\n    }\n\n    public async connect(): Promise<void> {\n        if (!this._initialized) {\n            if (!this._initializing) {\n                this._initializing = this.initialize();\n            }\n            await this._initializing;\n        }\n    }\n\n    private async initialize(): Promise<void> {\n        if (this._initialized) return;\n        \n        try {\n            // Initialize symbol conversion first\n            await this.symbolConversion.initialize();\n            \n            // Connect WebSocket if enabled\n            if (this.enableWs) {\n                try {\n                    await this.ws.connect();\n                } catch (wsError: unknown) {\n                    const errorMessage = wsError instanceof Error ? wsError.message : String(wsError);\n                    console.warn('Failed to establish WebSocket connection:', errorMessage);\n                    if (errorMessage.includes('Please install the ws package')) {\n                        console.warn('To enable WebSocket support, please run: npm install ws');\n                        this.enableWs = false;\n                    }\n                    // Don't throw here - we want to continue initialization even if WebSocket fails\n                }\n            }\n            \n            this._initialized = true;\n            this._initializing = null;\n        } catch (error) {\n            this._initializing = null;\n            throw error;\n        }\n    }\n\n    public async ensureInitialized(): Promise<void> {\n        await this.connect();\n    }\n\n    private initializePrivateKey(privateKey: string, testnet: boolean): void {\n        try {\n            const formattedPrivateKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;\n            new ethers.Wallet(formattedPrivateKey); // Validate the private key\n            \n            this.exchange = new ExchangeAPI(\n                testnet, \n                formattedPrivateKey, \n                this.info, \n                this.rateLimiter, \n                this.symbolConversion, \n                this.walletAddress,\n                this,\n                this.vaultAddress\n            );\n            \n            this.custom = new CustomOperations(\n                this.exchange, \n                this.info, \n                formattedPrivateKey, \n                this.symbolConversion, \n                this.walletAddress\n            );\n            \n            this.isValidPrivateKey = true;\n        } catch (error) {\n            console.warn(\"Invalid private key provided. Some functionalities will be limited.\");\n            this.isValidPrivateKey = false;\n        }\n    }\n\n    private createAuthenticatedProxy<T extends object>(Class: new (...args: any[]) => T): T {\n        return new Proxy({} as T, {\n            get: (target, prop) => {\n                if (!this.isValidPrivateKey) {\n                    throw new AuthenticationError('Invalid or missing private key. This method requires authentication.');\n                }\n                return target[prop as keyof T];\n            }\n        });\n    }\n\n    private initializeWithPrivateKey(privateKey: string, testnet: boolean = false): void {\n        try {\n            const formattedPrivateKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}` as `0x${string}`;\n            new ethers.Wallet(formattedPrivateKey); // Validate the private key\n            \n            this.exchange = new ExchangeAPI(\n                testnet, \n                formattedPrivateKey, \n                this.info, \n                this.rateLimiter, \n                this.symbolConversion, \n                this.walletAddress,\n                this,\n                this.vaultAddress\n            );\n            this.custom = new CustomOperations(this.exchange, this.info, formattedPrivateKey, this.symbolConversion, this.walletAddress);\n            this.isValidPrivateKey = true;\n        } catch (error) {\n            console.warn(\"Invalid private key provided. Some functionalities will be limited.\");\n            this.isValidPrivateKey = false;\n        }\n    }\n\n    // Modify existing methods to check initialization\n    public isAuthenticated(): boolean {\n        this.ensureInitialized();\n        return this.isValidPrivateKey;\n    }\n\n    public isWebSocketConnected(): boolean {\n        return this.ws?.isConnected() ?? false;\n    }\n\n    disconnect(): void {\n        if (this.ws) {\n            this.ws.close();\n        }\n    }\n\n    public getBaseUrl(): string {\n        return this.baseUrl;\n    }\n\n    public getRateLimiter(): RateLimiter {\n        return this.rateLimiter;\n    }\n}\n\nexport * from './types';\nexport * from './utils/signing';\n","import { HttpApi } from './helpers';\nimport * as CONSTANTS from '../types/constants';\nimport { MetaAndAssetCtxs, SpotMetaAndAssetCtxs } from '../types';\n\nexport class SymbolConversion {\n    private assetToIndexMap: Map<string, number> = new Map();\n    private exchangeToInternalNameMap: Map<string, string> = new Map();\n    private httpApi: HttpApi;\n    private refreshIntervalMs: number = 60000;\n    private refreshInterval: any = null;\n    private initialized: boolean = false;\n\n    constructor(baseURL: string, rateLimiter: any) {\n        this.httpApi = new HttpApi(baseURL, CONSTANTS.ENDPOINTS.INFO, rateLimiter);\n    }\n\n    async initialize(): Promise<void> {\n        if (this.initialized) return;\n        \n        try {\n            await this.refreshAssetMaps();\n            this.startPeriodicRefresh();\n            this.initialized = true;\n        } catch (error) {\n            console.error('Failed to initialize SymbolConversion:', error);\n            throw error;\n        }\n    }\n\n    private ensureInitialized(): void {\n        if (!this.initialized) {\n            throw new Error('SymbolConversion must be initialized before use. Call initialize() first.');\n        }\n    }\n\n    async getInternalName(exchangeName: string): Promise<string | undefined> {\n        this.ensureInitialized();\n        return this.exchangeToInternalNameMap.get(exchangeName);\n    }\n\n    private startPeriodicRefresh(): void {\n        if (this.refreshInterval !== null) {\n            clearInterval(this.refreshInterval);\n        }\n        \n        // Use standard setInterval that works in both Node.js and browser\n        this.refreshInterval = setInterval(() => {\n            this.refreshAssetMaps().catch(console.error);\n        }, this.refreshIntervalMs);\n    }\n\n    private async refreshAssetMaps(): Promise<void> {\n        try {\n            const [perpMeta, spotMeta] = await Promise.all([\n                this.httpApi.makeRequest<MetaAndAssetCtxs>({ \"type\": CONSTANTS.InfoType.PERPS_META_AND_ASSET_CTXS }),\n                this.httpApi.makeRequest<SpotMetaAndAssetCtxs>({ \"type\": CONSTANTS.InfoType.SPOT_META_AND_ASSET_CTXS })\n            ]);\n\n            this.assetToIndexMap.clear();\n            this.exchangeToInternalNameMap.clear();\n            \n            // Handle perpetual assets\n            perpMeta[0].universe.forEach((asset: { name: string }, index: number) => {\n                const internalName = `${asset.name}-PERP`;\n                this.assetToIndexMap.set(internalName, index);\n                this.exchangeToInternalNameMap.set(asset.name, internalName);\n            });\n\n            // Handle spot assets\n            spotMeta[0].tokens.forEach((token: any) => {\n                const universeItem = spotMeta[0].universe.find((item: any) => item.tokens[0] === token.index);\n                if (universeItem) {\n                    const internalName = `${token.name}-SPOT`;\n                    const exchangeName = universeItem.name;\n                    const index = universeItem.index;\n                    this.assetToIndexMap.set(internalName, 10000 + index);\n                    this.exchangeToInternalNameMap.set(exchangeName, internalName);\n                }\n            });\n        } catch (error) {\n            console.error('Failed to refresh asset maps:', error);\n        }\n    }\n\n    public async getExchangeName(internalName: string): Promise<string | undefined> {\n        await this.ensureInitialized();\n        for (const [exchangeName, name] of this.exchangeToInternalNameMap.entries()) {\n            if (name === internalName) {\n                return exchangeName;\n            }\n        }\n        return undefined;\n    }\n\n    public async getAssetIndex(assetSymbol: string): Promise<number | undefined> {\n        await this.ensureInitialized();\n        return this.assetToIndexMap.get(assetSymbol);\n    }\n\n    public async getAllAssets(): Promise<{ perp: string[], spot: string[] }> {\n        await this.ensureInitialized();\n        const perp: string[] = [];\n        const spot: string[] = [];\n\n        for (const [asset, index] of this.assetToIndexMap.entries()) {\n            if (asset.endsWith('-PERP')) {\n                perp.push(asset);\n            } else if (asset.endsWith('-SPOT')) {\n                spot.push(asset);\n            }\n        }\n\n        return { perp, spot };\n    }\n\n    async convertSymbol(symbol: string, mode: string = \"\", symbolMode: string = \"\"): Promise<string> {\n        await this.ensureInitialized();\n        let rSymbol: string;\n        if (mode === \"reverse\") {\n            for (const [key, value] of this.exchangeToInternalNameMap.entries()) {\n                if (value === symbol) {\n                    return key;\n                }\n            }\n            rSymbol = symbol;\n        } else {\n            rSymbol = this.exchangeToInternalNameMap.get(symbol) || symbol;\n        }\n\n        if (symbolMode === \"SPOT\") {\n            if (!rSymbol.endsWith(\"-SPOT\")) {\n                rSymbol = symbol + \"-SPOT\";\n            }\n        } else if (symbolMode === \"PERP\") {\n            if (!rSymbol.endsWith(\"-PERP\")) {\n                rSymbol = symbol + \"-PERP\";\n            }\n        }\n\n        return rSymbol;\n    }\n\n    async convertSymbolsInObject(obj: any, symbolsFields: Array<string> = [\"coin\", \"symbol\"], symbolMode: string = \"\"): Promise<any> {\n        await this.ensureInitialized();\n        if (typeof obj !== 'object' || obj === null) {\n            return this.convertToNumber(obj);   \n        }\n    \n        if (Array.isArray(obj)) {\n            return Promise.all(obj.map(item => this.convertSymbolsInObject(item, symbolsFields, symbolMode)));\n        }\n    \n        const convertedObj: any = {};\n        for (const [key, value] of Object.entries(obj)) {\n            if (symbolsFields.includes(key)) {\n                convertedObj[key] = await this.convertSymbol(value as string, \"\", symbolMode);\n            } else if (key === 'side') {\n                convertedObj[key] = value === 'A' ? 'sell' : value === 'B' ? 'buy' : value;\n            } else {\n                convertedObj[key] = await this.convertSymbolsInObject(value, symbolsFields, symbolMode);\n            }\n        }\n        return convertedObj;\n    }\n\n    convertToNumber(value: any): any {\n        if (typeof value === 'string') {\n            if (/^-?\\d+$/.test(value)) {\n                return parseInt(value, 10);\n            } else if (/^-?\\d*\\.\\d+$/.test(value)) {\n                return parseFloat(value);\n            }\n        }\n        return value;\n    }\n\n    async convertResponse(\n        response: any,\n        symbolsFields: string[] = [\"coin\", \"symbol\"],\n        symbolMode: string = \"\"\n    ): Promise<any> {\n        return this.convertSymbolsInObject(response, symbolsFields, symbolMode);\n    }\n}"],"mappings":"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","names":["BASE_URLS","WSS_URLS","ENDPOINTS","SDK_CODE","GeneralInfoAPI","httpApi","symbolConversion","parent","rawResponse","response","convertedResponse","key","value","convertedKey","convertedValue","user","startTime","endTime","params","oid","coin","interval","builder","vaultAddress","source","aggregateByTime","SpotInfoAPI","httpApi","symbolConversion","rawResponse","response","user","tokenId","PerpetualsInfoAPI","httpApi","symbolConversion","parent","rawResponse","response","user","startTime","endTime","coin","symbol","axios","HyperliquidAPIError","code","message","AuthenticationError","handleApiError","error","HttpApi","baseUrl","endpoint","rateLimiter","axios","payload","weight","error","handleApiError","InfoAPI","baseURL","rateLimiter","symbolConversion","parent","HttpApi","ENDPOINTS","GeneralInfoAPI","SpotInfoAPI","PerpetualsInfoAPI","assetName","exchangeName","rawResponse","user","startTime","endTime","oid","coin","interval","builder","vaultAddress","source","aggregateByTime","ethers","encode","ethers","getBytes","keccak256","phantomDomain","agentTypes","orderTypeToWire","orderType","floatToWire","addressToBytes","address","actionHash","action","vaultAddress","nonce","normalizedAction","normalizeTrailingZeros","msgPackBytes","additionalBytesLength","data","view","constructPhantomAgent","hash","isMainnet","signL1Action","wallet","activePool","phantomAgent","signInner","signUserSignedAction","payloadTypes","primaryType","signUsdTransferAction","signWithdrawFromBridgeAction","signAgent","signature","splitSig","sig","r","s","v","x","rounded","normalized","removeTrailingZeros","value","floatToIntForHashing","floatToInt","floatToUsdInt","power","withDecimals","getTimestampMs","orderToWire","order","asset","orderWire","orderWireToAction","orders","grouping","builder","obj","item","result","key","cancelOrderToAction","cancelRequest","ExchangeAPI","testnet","privateKey","info","rateLimiter","symbolConversion","walletAddress","parent","vaultAddress","baseURL","BASE_URLS","HttpApi","ENDPOINTS","ethers","symbol","index","orderRequest","grouping","builder","ordersArray","assetIndexCache","normalizedOrders","order","normalizedOrder","removeTrailingZeros","orderWires","o","assetIndex","orderToWire","actions","orderWireToAction","nonce","signature","signL1Action","payload","error","cancelRequests","cancels","cancelsWithIndices","req","action","a","cloid","oid","orderWire","modifies","assetIndices","m","normalizedModifies","leverageMode","leverage","isBuy","ntli","destination","amount","signUsdTransferAction","token","signUserSignedAction","signWithdrawFromBridgeAction","usdc","toPerp","time","isDeposit","usd","code","SDK_CODE","usingBigBlocks","twapWire","cancelRequest","request","signAgent","timestamp","environment","nodeVersion","_a","WebSocketClient","testnet","maxReconnectAttempts","WSS_URLS","environment","_a","_b","resolve","reject","event","message","error","delay","timer","err","handler","handlers","args","WebSocketSubscriptions","ws","symbolConversion","type","params","key","callback","_a","callbacks","subscription","error","convertedSubscription","message","channel","additionalChecks","data","convertedData","subscriptionKey","messageHandler","value","convertedKey","convertedValue","user","coin","interval","convertedCoin","convertedMessage","requestType","payload","id","convertedPayload","resolve","reject","responseHandler","convertedResponse","RateLimiter","now","newTokens","weight","waitTimeMs","resolve","ethers","CustomOperations","exchangeOrParent","infoApiOrPrivateKey","privateKeyOrSymbolConversion","symbolConversionOrWalletAddress","walletAddress","Hyperliquid","ethers","_a","symbol","address","openOrders","ordersToCancel","order","cancelRequests","error","isBuy","slippage","px","convertedSymbol","allMids","isSpot","decimals","size","cloid","slippagePrice","orderRequest","positions","position","item","szi","closeSize","closeOrders","ethers","SymbolConversion","baseURL","rateLimiter","HttpApi","ENDPOINTS","error","exchangeName","perpMeta","spotMeta","asset","index","internalName","token","universeItem","item","name","assetSymbol","perp","spot","symbol","mode","symbolMode","rSymbol","key","value","obj","symbolsFields","convertedObj","response","Hyperliquid","params","enableWs","privateKey","testnet","walletAddress","vaultAddress","maxReconnectAttempts","environment","BASE_URLS","RateLimiter","SymbolConversion","InfoAPI","CustomOperations","WebSocketClient","WebSocketSubscriptions","wsError","errorMessage","error","formattedPrivateKey","ethers","ExchangeAPI","Class","target","prop","AuthenticationError","_a"]}